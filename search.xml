<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Activiti工作流流程部署入门</title>
      <link href="post/bdac.html"/>
      <url>post/bdac.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-1流程定义部署"><a href="#1-1流程定义部署" class="headerlink" title="1.1流程定义部署"></a>1.1流程定义部署</h1><h2 id="1-1-1、使用流程设计器，使用流程符号，画出流程图"><a href="#1-1-1、使用流程设计器，使用流程符号，画出流程图" class="headerlink" title="1.1.1、使用流程设计器，使用流程符号，画出流程图"></a>1.1.1、使用流程设计器，使用流程符号，画出流程图</h2><p><strong>bpmn文件，png文件</strong><br><strong>都是流程资源文件，用来描述流程，流程中需要的节点，节点的负责人</strong><br><strong>出差申请流程，请假申请流程，报销申请流程</strong>  </p><h2 id="1-1-2、把流程的资源文件，进行部署"><a href="#1-1-2、把流程的资源文件，进行部署" class="headerlink" title="1.1.2、把流程的资源文件，进行部署"></a>1.1.2、把流程的资源文件，进行部署</h2><p><strong>上传到数据库中，使用java代码来进行流程部署</strong><br><strong>一次部署操作：ACT_RE_DEPLOYMENT：流程部署表，每部署一次增加一条记录</strong><br><strong>ACT_RE_PROCDEF：生成流程定义信息，部署每个新的流程定义都会在这张表中增加一条记录</strong><br><strong>act_ge_bytearray：流程资源表</strong>   </p><h2 id="1-1-3、deployment-和procdef表一对多的关系"><a href="#1-1-3、deployment-和procdef表一对多的关系" class="headerlink" title="1.1.3、deployment 和procdef表一对多的关系"></a>1.1.3、deployment 和procdef表一对多的关系</h2><p><strong>在procdef表中可以有多条记录，每条记录对应一个流程的定义信息</strong><br><strong>张三 出差申请</strong><br><strong>李四 出差申请</strong>    </p><ul><li><strong>注意：</strong>  </li></ul><p>act_re_deployment和act_re_procdef一对多关系，一次部署在流程部署表生成一条记录，但一次部署可以部署多个流程定义，每个流程定义在流程定义表生成一条记录。每一个流程定义在act_ge_bytearray会存在两个资源记录，bpmn和png。 </p><p>建议：一次部署一个流程，这样部署表和流程定义表是一对一有关系，方便读取流程部署及流程定义信息。  </p><h1 id="2-1总结回顾"><a href="#2-1总结回顾" class="headerlink" title="2.1总结回顾"></a>2.1总结回顾</h1><h2 id="2-1-1、Actibiti的表说明"><a href="#2-1-1、Actibiti的表说明" class="headerlink" title="2.1.1、Actibiti的表说明"></a>2.1.1、Actibiti的表说明</h2><ul><li><p><strong>使用25张表</strong>  </p><blockquote><p>   ACT_RE : ‘RE’表示repository。这个前缀的表包含了流程定义和流程静态资源（图片，规则，等等）。<br>  ACT_RU : ‘RU’表示runtime。这些运行时的表包含流程实例任务，变量，异步任务等运行中的数据Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。<br>  ACT_HI：’HI’表示histroy。这些包含历史记录，比如历史流程记录实例，变量，任务等等。<br>  ACT_GE: ‘GE’表示general。通用数据，用于不同场景下  </p></blockquote><h2 id="2-2-2、Activiti的架构、类关系图"><a href="#2-2-2、Activiti的架构、类关系图" class="headerlink" title="2.2.2、Activiti的架构、类关系图"></a>2.2.2、Activiti的架构、类关系图</h2><blockquote><p>   获取流程引擎的工具类<br>  ProcessEngines.使用默认方式获取配置文件，构造流程引擎。配置文件名字activiti.cfg.xml，放在classpath下<br>  ProcessEngineConfiguration.可以自定义配置文件名<br>  使用上面2个工具类，都可以获取流程引擎<br>  ProcessEngine：流程引擎。获取各种服务的接口。<br>  服务接口：用于部署、执行、管理，使用这些接口就是在操作对应的数据表  </p><pre><code>      RepositoryService     资源管理类        RuntimeService        运行时管理类        TaskService           任务管理类        HistoryService        历史数据管理类        ManagementService     流程引擎管理类</code></pre></blockquote><h2 id="2-2-3、BPMN插件"><a href="#2-2-3、BPMN插件" class="headerlink" title="2.2.3、BPMN插件"></a>2.2.3、BPMN插件</h2><h2 id="2-2-4、流程符号、画流程图"><a href="#2-2-4、流程符号、画流程图" class="headerlink" title="2.2.4、流程符号、画流程图"></a>2.2.4、流程符号、画流程图</h2><blockquote><p>   流程符号：事件Event、活动Activity,网关 Gateway，流向<br>  使用流程设计器画出流程图<br>  bpmn文件本质上是xml文件，因为安装了actiBPM插件才能可视化的看到流程内容<br>  创建bpmn文件，在流程设计器使用流程符号来表达流程,指定流程的Key，指定任务负责人<br>  生成PNG文件，把bpmn文件后缀改为xml，在这个文件上右键选择Diagrams-&gt;show BPMN2.0 Desinger,打开窗口，点击导出文件按钮，选择导出文件的类型为PNG。要注意乱码问题</p></blockquote><h2 id="2-2-5、部署流程"><a href="#2-2-5、部署流程" class="headerlink" title="2.2.5、部署流程"></a>2.2.5、部署流程</h2><blockquote><p>   使用Activiti提供的API把流程图的内容写入数据库中<br>  属于资源类操作，使用RepositoryService<br>  单文件部署：把bpmn文件和png文件一个一个处理<br>  压缩包部署：把bpmn文件和png文件打压缩包来处理<br>  核心代码：<br>  Deployment deploy = repositoryService.createDeployment()<br>  部署操作表：<br>  act_re_deployment 部署表<br>  act_re_procdef 流程定义表<br>  act_ge_bytearray   资源表   </p></blockquote></li><li><p><strong>单文件部署代码</strong>  </p><pre><code>@Test  public void testDeployment(){      //1.创建ProcessEngine      //先构建ProcessEngineConfiguration      ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml",              "processEngineConfiguration");      ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();      //2.获取RepositoryService      RepositoryService rs = processEngine.getRepositoryService();      //3.使用service进行流程的部署，定义一个流程的名字，把bpmn和png部署到数据库中      Deployment deploy = rs.createDeployment().name("出差申请流程")              .addClasspathResource("bpmn/evection.bpmn")              .addClasspathResource("bpmn/evection.png")              .deploy();      //4、输出部署信息      System.out.println("流程部署id="+deploy.getId());      System.out.println("流程部署名称="+deploy.getName());  }</code></pre></li><li><p><strong>压缩包部署代码</strong>  </p><pre><code>@Test  public void deployProcessByZip(){      //    获取流程引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();      //    获取RepositoryService服务      RepositoryService repositoryService = processEngine.getRepositoryService();      //     流程部署      //    读取资源包文件，构造成inputStream      InputStream inputStream = this.getClass()              .getClassLoader()              .getResourceAsStream("bpmn/evection.zip");      //  用inputStream 构造 ZipInputStream      ZipInputStream zipInputStream = new ZipInputStream(inputStream);      //  使用压缩包的流进行流程的部署      Deployment deploy = repositoryService.createDeployment()              .addZipInputStream(zipInputStream)              .deploy();      System.out.println("流程部署ID:"+deploy.getId());      System.out.println("流程部署名称"+deploy.getName());  }</code></pre><h2 id="2-2-6、启动流程实例"><a href="#2-2-6、启动流程实例" class="headerlink" title="2.2.6、启动流程实例"></a>2.2.6、启动流程实例</h2><blockquote><p>   使用RuntimeService根据流程定义的Key<br>  核心代码：<br>  ProcessInstance instance = runtimeService.startProcessInstanceByKey(“myEvection”);<br>  操作表：  </p><pre><code>  /*    * 启动流程实例    * 'act_hi_actinst' 流程实例执行历史    * 'act_hi_identitylink' 流程参与者的历史信息    * 'act_hi_procinst' 流程实例的历史信息    * 'act_hi_taskinst' 任务的历史信息    * 'act_ru_execution' 流程执行的信息    * 'act_ru_identitylink' 流程参与者信息    * 'act_ru_task' 任务信息    * */  </code></pre></blockquote></li><li><p><strong>流程实例代码</strong>  </p><pre><code>@Test  public void testStartProcess(){//    1.创建ProcessEngine      ProcessEngine processengine = ProcessEngines.getDefaultProcessEngine();//    2.获取RunTimeService      RuntimeService runtimeService = processengine.getRuntimeService();//    3.根据流程定义的id启动流程      ProcessInstance instance = runtimeService.startProcessInstanceByKey("myEvection");//    4.输出内容      System.out.println("流程定义ID:"+instance.getProcessDefinitionId());      System.out.println("流程实例ID："+instance.getId());      System.out.println("流程活动的ID:"+instance.getActivityId());  }</code></pre><h2 id="2-2-7、任务查询"><a href="#2-2-7、任务查询" class="headerlink" title="2.2.7、任务查询"></a>2.2.7、任务查询</h2><blockquote><p>   使用TaskService,根据流程定义的Key，任务的负责人来进行查询<br>  核心代码：<br>  taskService.createTaskQuery()<br>  .processDefinitionKey(“MyEvection”) //流程key<br>  .taskAssignee(“zhangsan”) //要查询的负责人<br>  .list();  </p></blockquote></li><li><p><strong>任务查询代码</strong>  </p><pre><code>@Test  public void testFindPersonalTaskList(){  //    1.读取流程引擎      ProcessEngineConfiguration pecfr = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml", "processEngineConfiguration");      ProcessEngine processEngine = pecfr.buildProcessEngine();  //    2.获取taskService      TaskService taskService = processEngine.getTaskService();  //    3.根据流程key 和 任务负责人 查询任务      List&lt;Task&gt; taskList = taskService.createTaskQuery()              .processDefinitionKey("myEvection") //流程定义key              .taskAssignee("zhangsan") //任务负责人名称              .list();      //    4.输出      for (Task task : taskList) {          System.out.println("流程实例ID = "+task.getProcessDefinitionId());          System.out.println("任务ID = "+task.getId());          System.out.println("任务负责人 = "+task.getAssignee());          System.out.println("任务名称 = "+task.getName());      }  }</code></pre><h2 id="2-2-8、任务完成"><a href="#2-2-8、任务完成" class="headerlink" title="2.2.8、任务完成"></a>2.2.8、任务完成</h2><blockquote><p>   使用TaskService，用任务Id完成任务<br>  核心代码：<br>  taskService.complete(“5005”);  </p></blockquote></li><li><p><strong>任务完成代码</strong>  </p><pre><code>@Test  public void completeTask1(){  //    获取流程引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();  //    获取TaskService      TaskService taskService = processEngine.getTaskService();  //    根据任务id完成任务      taskService.complete("5005");      System.out.println("完成个人任务！");  }</code></pre></li><li><p><strong>结合任务查询和任务完成代码</strong>  </p><pre><code>@Test  public void completeTask2(){  //    获取流程引擎      ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml", "processEngineConfiguration");      ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();      //    获取TaskService操作任务的服务      TaskService taskService = processEngine.getTaskService();      //获取liuchuanwang - myEvection的任务  //    Task task = taskService.createTaskQuery()  //            .processDefinitionKey("myEvection")  //            .taskAssignee("liuchuanwang")  //            .singleResult();  //    System.out.println("流程实例ID = "+task.getProcessDefinitionId());  //    System.out.println("任务ID = "+task.getId());  //    System.out.println("任务负责人 = "+task.getAssignee());  //    System.out.println("任务名称 = "+task.getName());  //    根据任务id完成liuchuanwang任务  //    taskService.complete(task.getId());      //获取dengyonfeng - myEvection的任务      //Task task = taskService.createTaskQuery()      //        .processDefinitionKey("myEvection")      //        .taskAssignee("dengyonfeng")      //        .singleResult();      //System.out.println("流程实例ID = "+task.getProcessDefinitionId());      //System.out.println("任务ID = "+task.getId());      //System.out.println("任务负责人 = "+task.getAssignee());      //System.out.println("任务名称 = "+task.getName());          //    根据任务id完成dengyonfeng任务      //taskService.complete(task.getId());      //获取yangqi - myEvection的任务      Task task = taskService.createTaskQuery()              .processDefinitionKey("myEvection")              .taskAssignee("yangqi")              .singleResult();      System.out.println("流程实例ID = "+task.getProcessDefinitionId());      System.out.println("任务ID = "+task.getId());      System.out.println("任务负责人 = "+task.getAssignee());      System.out.println("任务名称 = "+task.getName());      //    完成的liuchuanwang任务，完成dengyonfeng的任务，完成yangqi的任务      taskService.complete(task.getId());  }</code></pre><h2 id="2-3-1-流程定义信息查询"><a href="#2-3-1-流程定义信息查询" class="headerlink" title="2.3.1 流程定义信息查询"></a>2.3.1 流程定义信息查询</h2><blockquote><p>   查询流程相关信息，包含流程定义，流程部署，流程定义版本<br>  查询操作表：<br>  ACT_RE_PROCDEF 已部署的流程定义表<br>  核心代码：  </p><pre><code>      ProcessDefinitionQuery definitionQuery = repositoryService.createProcessDefinitionQuery();        List&lt;ProcessDefinition&gt; definitionList = definitionQuery.processDefinitionKey("myEvection")        .orderByProcessDefinitionVersion()        .desc()        .list();  </code></pre></blockquote></li><li><p><strong>流程定义查询代码</strong>  </p><pre><code>@Test  public void queryProcessDefinition(){  //    获取流程引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();  //    获取repositoryService      RepositoryService repositoryService = processEngine.getRepositoryService();  //    获取ProcessDefinitionQuery对象      ProcessDefinitionQuery definitionQuery = repositoryService.createProcessDefinitionQuery();  //    查询当前所有的流程定义，返回流程定义信息的集合  //    processDefinitionKey(流程定义Key)  //    orderByProcessDefinitionVersion() 通过版本号进行排序  //    desc 倒序  //    list 查询出所有的内容      List&lt;ProcessDefinition&gt; definitionList = definitionQuery.processDefinitionKey("myEvection")              .orderByProcessDefinitionVersion()              .desc()              .list();  //输出信息      for (ProcessDefinition processDefinition : definitionList) {          System.out.println("流程定义Id = "+processDefinition.getId());          System.out.println("流程定义Name = "+processDefinition.getName());          System.out.println("流程定义Key = "+processDefinition.getKey());          System.out.println("流程定义Version = "+processDefinition.getVersion());      }  }</code></pre><h2 id="2-3-2-删除流程部署"><a href="#2-3-2-删除流程部署" class="headerlink" title="2.3.2 删除流程部署"></a>2.3.2 删除流程部署</h2><blockquote><p>   流程删除<br>  删除操作表：<br>  act_re_deployment 部署表<br>  act_re_procdef 流程定义表<br>  act_ge_bytearray   资源表<br>  核心代码：<br>  repositoryService.deleteDeployment(部署ID);<br>  说明：<br>  1） 使用repositoryService 删除流程定义，历史表信息不会被删除<br>  2） 如果该流程定义下没有正在运行的流程，则可以用普通删除。<br>  如果该流程定义下存在运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除<br>  先删除没有完成流程节点，最后就可以完成删除流程定义信息<br>  项目开发中级联删除操作一般只开放给超级管理员使用。<br>  核心代码：<br>  reposotoryService,deleteDeployment(部署id,true);<br>  true:表示开启级联删除，默认为false。  </p></blockquote></li><li><p><strong>删除流程部署代码</strong>  </p><pre><code>@Test  public void deleteDeployment(){  //    1.获取流程引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();  //    2.通过流程引擎获取repositoryService      RepositoryService repositoryService = processEngine.getRepositoryService();  //    3.通过部署id来删除流程部署信息  //    3.1获取ProcessDefinitionQuery对象      ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();  //    3.2查询当前所有流程定义，返回流程定义的集合      List&lt;ProcessDefinition&gt; processDefinitionList = processDefinitionQuery.processDefinitionKey("myProcess_1")              .orderByProcessDefinitionVersion()              .desc()              .list();      for (ProcessDefinition processDefinition : processDefinitionList) {          System.out.println("流程部署ID:"+processDefinition.getDeploymentId());          //    通过部署id来删除流程部署信息          //repositoryService.deleteDeployment(processDefinition.getDeploymentId());           repositoryService.deleteDeployment(processDefinition.getDeploymentId(),true);      }  }</code></pre><h2 id="2-3-3-流程资源下载"><a href="#2-3-3-流程资源下载" class="headerlink" title="2.3.3 流程资源下载"></a>2.3.3 流程资源下载</h2><blockquote><p>   现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中把资源文件下载到本地。<br>  解决方案：  </p><pre><code>  /*    * 下载 资源文件    * 方案一：使用Activiti提供的api，来下载资源文件，保存到文件目录    * 方案二：自己写代码从数据库中下载文件，使用jdbc对blob类型，clob类型数据读取出来，保存到文件目录    * 解决Io操作：commons-io.jar    * 这里我们使用方案一，Activiti提供的api:RepositoryService    * */   </code></pre></blockquote></li></ul><p>commons-io 依赖包   </p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li><p><strong>代码实现</strong>  </p><pre><code>@Test  public void getDeployment() throws IOException {  //    1.获取流程引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();  //    2.获取api:RepositoryService      RepositoryService repositoryService = processEngine.getRepositoryService();  //3.获取查询对象 ProcessDefinitionQuery，查询流程定义信息      ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();      ProcessDefinition processDefinition = processDefinitionQuery.processDefinitionKey("myEvection").singleResult();      //    4.通过流程定义信息，获取部署ID      String deploymentId = processDefinition.getDeploymentId();  //    5.通过RepositoryService,传递部署id参数，读取资源信息（png和bpmn）  //       5.1、获取png图片的流  //    从流程定义表中，获取png图片的目录和名字      String pngName = processDefinition.getDiagramResourceName();      //通过 部署id和 文件名字来获取图片的资源      InputStream pngInput = repositoryService.getResourceAsStream(deploymentId, pngName);      //       5.2、获取bpmn的流  //    从流程定义表中，获取bpmn文件      String bpmnName = processDefinition.getResourceName();      //通过 部署ID和 文件名字来获取bpmn的资源      InputStream bpmnInput = repositoryService.getResourceAsStream(deploymentId, bpmnName);      //    6、构造OutputStream流      File pngFile = new File("e:/act/evectionflow01.png");      File bpmnFile = new File("e:/act/evectionflow01.bpmn");      FileOutputStream pngOutputStream = new FileOutputStream(pngFile);      FileOutputStream bpmnOutputStream = new FileOutputStream(bpmnFile);      //    7.输入流，输出流的转换      IOUtils.copy(pngInput, pngOutputStream);      IOUtils.copy(bpmnInput, bpmnOutputStream);  //    8.关闭流      pngOutputStream.close();      bpmnOutputStream.close();      pngInput.close();      bpmnInput.close();  }  </code></pre></li></ul><p><strong>说明</strong>  </p><ol><li>deploymentId为流程部署Id  </li><li>resource_name为act_ge_bytearray表中NAME_列的值  </li><li>使用repositoryService的getDeploymentResourceNames方法可以获取指定部署下得所有文件的名称  </li><li>使用repositoryService的getResourceAsStream方法传入部署ID和资源图片名称可以获取部署下指定名称文件的输入流<br>最后的将输入流中的图片资源进行输出。  <h2 id="2-3-4-流程历史信息的查看"><a href="#2-3-4-流程历史信息的查看" class="headerlink" title="2.3.4 流程历史信息的查看"></a>2.3.4 流程历史信息的查看</h2><blockquote><p>  即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在activiti的act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过HistoryService来查看相关的历史记录。  </p></blockquote></li></ol><ul><li><p><strong>代码实现</strong>  </p><pre><code>@Test  public void findHistoryInfo(){  //    获取引擎      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();  //    获取HistoryService      HistoryService historyService = processEngine.getHistoryService();  //    获取actinst表的查询对象      HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();  //    查询actinst表，条件：根据字段 PROC_INST_ID_ 查询  //    instanceQuery.processInstanceId("5001");  //    查询actinst表，条件：根据字段PROC_DEF_ID_ 查询  //    instanceQuery.processDefinitionId("myEvection:1:2504");  //    查询actinst表，条件：根据字段EXECUTION_ID_ 查询      instanceQuery.executionId("5002");  //    给actinst表增加排序操作，通过开始创建时间进行升序排序      instanceQuery.orderByHistoricActivityInstanceStartTime().asc();  //    查询所有的内容      List&lt;HistoricActivityInstance&gt; historyActivityInstance = instanceQuery.list();  //    输出      for (HistoricActivityInstance hi : historyActivityInstance) {          System.out.println("活动id = "+hi.getActivityId());          System.out.println("活动名称 = "+hi.getActivityName());          System.out.println("流程定义ID = "+hi.getProcessDefinitionId());          System.out.println("流程实例id = "+hi.getProcessInstanceId());          System.out.println("执行id = "+hi.getExecutionId());          System.out.println("&gt;=========================");      }  }</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Activiti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注解容器组件注册</title>
      <link href="post/ef5d.html"/>
      <url>post/ef5d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring源码导读"><a href="#Spring源码导读" class="headerlink" title="Spring源码导读"></a>Spring源码导读</h1><ul><li><strong>1.本文是一篇spring源码相关的文章。众所周知，读源码是一件令人恐惧的事情，看源码相关的博客、书和文章亦是如此。</strong>  </li><li><strong>2.在正式开始spring源码导读之前，读者总得知道spring里的各个标签是干啥的吧，因此文中前一部分罗列了spring常见的注解用法。并搞了点SpringAOP和spring事务源码的解析作为后面正式开始的导读的开胃菜</strong>  </li><li><strong>3.介绍完了，让我们开始吧！！！</strong>  <h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1></li><li><strong>@configuration 用于标准配置类</strong>  </li><li><strong>@Bean 结合@Configuration（full mode）使用或结合@Component（light mode）使用。可以导入第三方组件,如方法有参数默认从IOC容器中获取，可以指定initMethod和destroyMethod 指定初始化和销毁方法,多实例对象不会调用销毁方法.</strong>  </li><li><strong>@Scope:设置组件作用域 1.prototype:多例的2.singleton:单例的（默认值）</strong>  </li><li><strong>@lazy 懒加载</strong>  </li><li><strong>@Conditional({Condition}):按照一定的条件进行判断,满足条件给容器中注册Bean,传入Condition数组,，使用时需自己创建类继承Condition然后重写match方法。</strong>  </li><li><strong>@Import[快速给容器中导入一个组件]</strong>  </li></ul><p><strong>1.Import(类名),容器中就会自动注册这个组件，id默认是组件的全名</strong><br><strong>2.ImportSelector：返回需要导入的组件的全类名的数组</strong><br><strong>3.ImportBeanDefinitionRegistrar：手动注册bean</strong></p><pre><code>&lt;bean id="person" class="com.jxgm.bean.Person" Scope="prototype"&gt;    &lt;property name="age" value="18"&gt;&lt;/property&gt;    &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt;&lt;/bean&gt;  </code></pre><p><strong>注解方式</strong>  </p><pre><code>    //声明该类为configuration类或component类      @Bean(value="person1")      public Person person(){        return new Person("zhangsan",18);    }   </code></pre><ul><li><strong>包扫描@ComponentScan (@ComponentScans可以配置多个扫描,@TypeFilter:指定过 滤规则,自己实现TypeFilter类)<br>组件(@Service、@Controller、@Repository):包扫描+组件注解导入注解。</strong>    </li></ul><p><strong>xml文件方式</strong></p><pre><code>&lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component--&gt;&lt;context:component-scan base-package="com.jxgm"&gt;&lt;/context&gt;  </code></pre><p><strong>注解方式</strong>  </p><pre><code>@Configuration  //告诉Spring这是一个配置类@ComponentScan(value="com.jxgm包名"，excludeFilters = {    @Filter(type=FilterType.ANNOTATION,classes={Controller.class,Service.class})})@ComponentScan(value="com.jxgm包名"，includeFilters = {    @Filter(type=FilterType.ANNOTATION,classes={Controller.class,Service.class}),    @Filter(type=FilterType.ASSIGNABLE_TYPE,classes={BookService.class}),    @Filter(type=FilterType.CUSTOM,classes={MyTypeFilter.class})    },useDefaultFilters = false)})//ComponentScan     value:指定要扫描的包//excludeFileters = Filter[] : 指定扫描的时候按照什么规则排除那些组件//includeFileters = Filter[] : 指定扫描的时候只需要包含哪些组件//FilterType.ANNOTAION：按照注解;//FilterType.ASSIGNABLE_TYPE：按照给定的类型;//FilterType.ASPECTJ：使用ASPECTJ表达式//FilterType.REGEX：使用正则指定//FilterType.CUSTOM：使用自定义规则//类中组件同一设置。满足当前条件，这个类中配置的所有bean注册才能生效；@Conditional({WindowsCondition.class})@Import({类名.class,类名.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})  //@Import导入组件，id默认是组件的全类名public class MainConfig(){    //给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id    //默认是单实例     /**     * Specifies the name of the scope to use for the annotated component/bean.     * @see ConfigurableBeanFactory#SCOPE_PROTOTYPE prototype     * @see ConfigurableBeanFactory#SCOPE_SINGLETON singleton     * @see org.springframework.web.context. WebApplicationContext#SCOPE_REQUEST  request     * @see org.springframework.web.context. WebApplicationContext#SCOPE_SESSION session     * @see #value       *      * prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。     *                      每次获取的时候才会调用方法创建对象；       * singleton：单实例的（默认值）:ioc容器启动会调用方法创建对象到ioc容器中。                        以后每次获取就是直接从容器（map.get()）中拿       * request ：同一次请求创建一个实例     * session ：同一个session创建一个实例       * @Scope：调整作用域       * 懒加载：     *      单实例bean:默认在容器启动的时候创建对象;     *      懒加载：容器启动不创建对象。第一次使用（获取）Bean创建对象，并初始化；     */    //@Scope("prototype")    @lazy    @Bean(value="person")      public Person person1(){        //单实例时：ioc容器启动调用方法创建对象时执行        System.out.println("给容器中添加Person……")        return new Person("zhangsan",18);    }    /**    @Conditional({Condition}):按照一定的条件进行判断，满足条件给容器中注册bean    如果系统是windows，给容器中注册（"bill"）    如果是linux系统，给容器中注册（"linus"）    */    //@Conditional({WindowsCondition.class})    @Bean("bill")    public Person person01(){        return new Person("Bill Gates",62);    }    @Conditional(LinuxCondition.class)    @Bean("linus")    public Person person02(){        return new Person("linus",48);    }    @Bean    public ColorFactorBean colorFactoryBean(){        return new ColorFactoryBean();    }}  &lt;!-- 使用自定义规则 --&gt;  public void MyTypeFilter implements TypeFilter{    /**    metadataReader:读取到的当前正在扫描的类的信息    metadataReaderFactory:可以获取到其他任何类的信息    */    @Override    public boolean match(MetadataReader metadataReader,MetadataReaderFactory metadataReaderFactory)            throws IOException{                //获取当前类注解的信息                AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();                //获取当前正在扫描的类的类信息                ClassMetadata classMetadata = metadataReader.getClassMetadata();                //获取当前类资源（类的路径）                Resource resource = metadataReader.getResource();                String className classMetadata.getClassName();                System.out.println("--&gt;"+className);                if(className.contains("er")){                    return true;                }                return false;            }}</code></pre><p><strong>在com.jxgm.condition下创建LinuxCondition.java和WindowsCondition.java</strong></p><pre><code>//判断是否为linux操作系统public class LinuxCondition implements Condition{    /**        ConditionContext：判断条件能使用的上下文（环境）        AnnotatedTypeMetadata：注释信息    */    @Override    public boolean matches(ConditionContext context,AnnotatedTypeMetadata metadata){        //是否linux系统        //1.能获取到ioc使用的beanfactory        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        //2.获取类加载器        ClassLoader classLoader = context.getClassLoader();        //3.获取当前环境信息        Environment environment = context.getEnvironment();        //4.获取到bean定义的注册类        BeanDefinitionRegistry registry = context.getRegistry();        String property = environment.getProperty("os.name");        if(property.contains("Linux")){            return true;        }        return false;    }}//判断是否为windows操作系统public class WindowsCondition implements Condition {    @Override    public boolean matches(ConditionContext context,AnnotatedTypeMetadata metadata){        //是否为Windows系统        Environment environment = context.getEnvironment();        String property = environment.getProperty("os.name");        if(property.contains("Windows")){            return true;        }        return false;    }}</code></pre><p><strong>测试类</strong>  </p><pre><code>AnnotationConfigApplicationContext applicationContext = new AnnotaionConfigApplicationContext(MainConfig.class);@Testpublic void test01(){    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);      String[] definitionNames = applicationContext.getBeanDefinition();    for(String name : definitionNames){        System.out.println(name);    }    System.out.println("ioc容器创建完成！");    Object bean = applicationContext.getBean("person");    Object bean2 = applicationContext.getBean("person");    System.out.println(bean == bean2);}  @Testpublic void test02(){    String[] namesForType = applicationContext.getBeanNamesForType(Person.class);    ConfigurableEnvironment environment = applicationContext.getEnvironment();    //动态获取变量的值；Windows 10    String property = environment.getProperty("os.name");    for(String name : namesForType){        System.out.println(name);    }    Map&lt;String,Person&gt; persons = applicationContext.getBeansOfType(Person.class);    System.out.println(persons);}</code></pre><h3 id="给容器中注册组件："><a href="#给容器中注册组件：" class="headerlink" title="给容器中注册组件："></a>给容器中注册组件：</h3><ul><li><strong>1）、包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</strong>  </li><li><strong>2）、@Bean[导入的第三方包里面的组件]</strong>  </li><li><strong>3）、@Import[快速给容器中导入一个组件]</strong>  </li></ul><p><strong>1)、@Import(要导入到容器中的组件)：容器中就会自动注册这个组件，id默认是全类名</strong><br><strong>2)、ImportSelecttor:返回需要导入的组件的全类名数组</strong><br><strong>3)、ImportBeanDefinitionRegistrar:手动注册bean到容器中</strong><br><strong>4)、使用Spring提供的FactoryBean(工厂Bean)</strong><br>1)、默认取到的是工厂bean调用getObject创建的对象<br>2)、要获取工厂Bean本身，我们需要给id前面加一个&amp; “&amp;colorFactoryBean”</p><p><strong>测试类</strong>  </p><pre><code>public class IocTest{    AnnotationConfigApplicationContext applicationContext = new AnnotaionConfigApplicationContext(MainConfig.class);    public void testImport(){        printBeans(applicationContext);    }    public void printBeans(AnnotationConfigApplicationContext applicationContext){        String[] difinitionNames = applicationContext.getBeanDefinitionNames();        for(String name : difinitionNames){            System.out.println(name);        }    }}</code></pre><p><strong>2)、在com.jxgm.condition下创建MyImportSelector.java实现ImportSelector接口</strong>   </p><pre><code>//自定义逻辑返回需要导入的组件public class MyImportSelector implements ImportSelector{    //返回值，就是导入到容器中的组件全类名    //AnnotationMetadata：当前标注@Import注解的类的所有注解信息    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata){        //方法不要返回null值        return new String[]{"全类名","全类名",……};    }}  </code></pre><p><strong>3）、在com.jxgm.condition下创建MyImportBeanDefinitionRegistrar.java实现ImportBeanDefinitionRegistrar接口</strong>  </p><pre><code>public calss MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{    /**    AnnotationMetadata：当前类的注解信息    BeanDefinitionRegistry:BeanDefinition注册类；            把所有需要添加到容器的bean；调用            BeanDefinitionRegistry.registerBeanDefinition手工注册进来    */    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,BeanDefinitionRegistry registry){        boolean definition = registry.containsBeanDefinition("全类名");        boolean definition2 = registry.containsBeanDefinition("全类名");        if(definition &amp;&amp; definition2){            //指定Bean定义信息；(Bean的类型，Bean...)            RootBeanDifinition beanDifinition = new RootBeanDefinition(类名.class);            //注册一个bean,指定Bean名            registry.registryBeanDefinition("类名"，beanDifinition);        }    }}</code></pre><p><strong>4）、在com.jxgm.bean下创建一个domain实现FactoryBean接口实现里面的方法</strong>  </p><pre><code>//创建一个Spring定义的FactoryBeanpublic class ColorFactoryBean implement FactoryBean&lt;Color&gt;{    //返回一个Color对象，这个对象对添加到容器中    @Override    public Color getObject() throws Exception {        return new Color();    }    //返回对象类型    @Override    public Class&lt;?&gt; getObjectType(){        return Color.class;    }    //判断对象是否为单例    //true：该对象为单实例，在容器中保存一份    //false：该对象是多实例，每次获取都会创建一个新的bean    @Override    public boolean isSingleton(){        return false;    }}</code></pre><p><strong>测试类</strong>  </p><pre><code>AnnotationConfigApplicationContext applicationContext = new AnnotaionConfigApplicationContext(MainConfig.class);Object bean = applicationContext.getBean("colorFactoryBean");Object bean2 = applicationContext.getBean("colorFactoryBean");System.out.println("bean类型:"+bean.getClass());System.out.println(bean2 == bean);  Object bean3 = applicationContext.getBean("&amp;colorFactoryBean");System.out.println(bean3.getClass());</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成Thymeleaf模板引擎</title>
      <link href="post/1fb4.html"/>
      <url>post/1fb4.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot集成Thymeleaf模板引擎"><a href="#SpringBoot集成Thymeleaf模板引擎" class="headerlink" title="SpringBoot集成Thymeleaf模板引擎"></a>SpringBoot集成Thymeleaf模板引擎</h1><h2 id="1-1-认识Thymeleaf"><a href="#1-1-认识Thymeleaf" class="headerlink" title="1.1 认识Thymeleaf"></a>1.1 认识Thymeleaf</h2><blockquote><p> Thymeleaf 是一个流行的模板引擎，该模板引擎采用 Java 语言开发<br>    模板引擎是一个技术名词，是跨领域跨平台的概念，在 Java 语言体系下有模板引擎，<br>    在 C#、PHP 语言体系下也有模板引擎，甚至在 JavaScript 中也会用到模板引擎技术，Java 生态下的模板引擎有 Thymeleaf 、Freemaker、Velocity、Beetl（国产） 等。<br>    Thymeleaf 对网络环境不存在严格的要求，既能用于 Web 环境下，也能用于非 Web 环境下。在非 Web 环境下，他能直接显示模板上的静态数据；在 Web 环境下，它能像 Jsp 一样从后台接收数据并替换掉模板上的静态数据。它是基于 HTML 的，以 HTML 标签为载体，Thymeleaf 要寄托在 HTML 标签下实现。<br>    SpringBoot 集成了 Thymeleaf 模板技术，并且 Spring Boot 官方也推荐使用 Thymeleaf 来替代 JSP 技术，Thymeleaf 是另外的一种模板技术，它本身并不属于 Spring Boot，Spring Boot只是很好地集成这种模板技术，作为前端页面的数据展示，在过去的 Java Web 开发中，我们往往会选择使用 Jsp 去完成页面的动态渲染，但是 jsp 需要翻译编译运行，效率低<br>    Thymeleaf 的官方网站：<a href="http://www.thymeleaf.org/">http://www.thymeleaf.org</a><br>    Thymeleaf 官方手册：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a>   </p></blockquote><h2 id="1-2-SpringBoot集成Thymeleaf"><a href="#1-2-SpringBoot集成Thymeleaf" class="headerlink" title="1.2 SpringBoot集成Thymeleaf"></a>1.2 SpringBoot集成Thymeleaf</h2><h3 id="1-2-1-在pom-xml文件中添加依赖"><a href="#1-2-1-在pom-xml文件中添加依赖" class="headerlink" title="1.2.1 在pom.xml文件中添加依赖"></a>1.2.1 在pom.xml文件中添加依赖</h3><ul><li><p>springboot框架集成thymeleaf模板引擎起步依赖  </p><pre><code>  &lt;!--springboot框架集成thymeleaf模板引擎起步依赖--&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;      &lt;/dependency&gt;  </code></pre></li></ul><h3 id="1-2-2-在SpringBoot核心文件中对Thymeleaf进行配置"><a href="#1-2-2-在SpringBoot核心文件中对Thymeleaf进行配置" class="headerlink" title="1.2.2 在SpringBoot核心文件中对Thymeleaf进行配置"></a>1.2.2 在SpringBoot核心文件中对Thymeleaf进行配置</h3><pre><code>#设置thymeleaf模拟引擎的缓存，设置为false关闭，默认为true开启spring.thymeleaf.cache=false#设置thymeleaf模板引擎的前/后缀（可选,可以不写），springboot默认配置为 /templates/*.xmlspring.thymeleaf.mode=HTMLspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html</code></pre><h3 id="1-2-3-创建Controller映射到模板页面（和SpringMVC基本一致）"><a href="#1-2-3-创建Controller映射到模板页面（和SpringMVC基本一致）" class="headerlink" title="1.2.3 创建Controller映射到模板页面（和SpringMVC基本一致）"></a>1.2.3 创建Controller映射到模板页面（和SpringMVC基本一致）</h3><pre><code>@Controllerpublic class IndexController {    @RequestMapping("/user/index.do")    public String index(Model model){        model.addAttribute("data","Springboot使用thymeleaf模板引擎");        return "index";    }}</code></pre><h3 id="1-2-4-在src-main-resource下的templates下新建index-html用于展示数据"><a href="#1-2-4-在src-main-resource下的templates下新建index-html用于展示数据" class="headerlink" title="1.2.4 在src/main/resource下的templates下新建index.html用于展示数据"></a>1.2.4 在src/main/resource下的templates下新建index.html用于展示数据</h3><p>HTML 页面的&lt;html&gt;元素中加入以下属性：</p><blockquote><p>xmlns:th=”<a href="http://www.thymeleaf.org&quot;/">http://www.thymeleaf.org"</a>  </p></blockquote><pre><code>&lt;!DOCTYPE html&gt;&lt;!--xmlns:th="http://www.thymeleaf.org"xmlns -&gt;命名空间命名空间后面的地址是一个约束文件，约束你使用thymeleaf表达式的一个规则文件，就好比我们之前在xml文件中的一些dtd文件--&gt;&lt;!--    为什么使用了th前缀就可以获取后台数据？    那是因为项目中添加了thymeleaf的核心依赖，它的核心依赖会去    解析thymeleaf自己定义的这些标签名称，通过thymeleaf自己的java核心    代码来获取我们的后台数据--&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--        &lt;!--Thymeleaf 前端框架以 Html 为载体--&gt;        thymeleaf模板引擎的页面必须通过中央调度器    --&gt;    &lt;h2 th:text="${data}"&gt;thymeleaf模板引擎&lt;/h2&gt;&lt;/body&gt;</code></pre><h3 id="1-2-5-启动程序，浏览器访问"><a href="#1-2-5-启动程序，浏览器访问" class="headerlink" title="1.2.5 启动程序，浏览器访问"></a>1.2.5 启动程序，浏览器访问</h3><ul><li><strong>注意： Springboot 使 用 thymeleaf 作 为 视 图 展 示 ， 约 定 将 模 板 文 件 放 置 在src/main/resource/templates 目录下，静态资源放置在 src/main/resource/static 目录下</strong>   <h2 id="2-2-Thymeleaf表达式"><a href="#2-2-Thymeleaf表达式" class="headerlink" title="2.2 Thymeleaf表达式"></a>2.2 Thymeleaf表达式</h2></li></ul><ol><li><p>创建实体 User实体类  </p><pre><code> public class User {     private Integer id;     private String name;     private Integer age;     public Integer getId() {         return id;     }     public void setId(Integer id) {         this.id = id;     }     public String getName() {         return name;     }     public void setName(String name) {         this.name = name;     }     public Integer getAge() {         return age;     }     public void setAge(Integer age) {         this.age = age;     } }</code></pre></li><li><p>创建ThymeleafController控制层类  </p><p> @Controller<br> public class ThymeleafController {</p><pre><code> @RequestMapping(value = "/index.do") public String index(Model model){     User user = new User();     user.setId(1001);     user.setName("zhangsan");     user.setAge(21);     model.addAttribute("user",user);     return "index"; }</code></pre><p> }</p></li><li><p>在src/main/resources/templates下创建html模板引擎  </p><h3 id="2-2-1-标准变量表达式"><a href="#2-2-1-标准变量表达式" class="headerlink" title="2.2.1 标准变量表达式"></a>2.2.1 标准变量表达式</h3></li></ol><ul><li><strong>注意：th:text=”” 是 Thymeleaf 的一个属性，用于文本的显示</strong>  </li></ul><ol start="4"><li><p>语法 ${…}  </p></li><li><p>说明<br>标准变量表达式用于访问容器（tomcat）上下文环境中的变量，功能和 EL 中的 ${} 相<br>同。Thymeleaf 中的变量表达式使用 ${变量名} 的方式获取 Controller 中 model 其中的数据  </p></li><li><p>代码  </p><pre><code> &lt;h1&gt;标准变量表达式：${} -&gt; 推荐&lt;/h1&gt;     用户标识:&lt;span th:text="${user.id}"&gt;&lt;/span&gt;&lt;br&gt;     用户姓名：&lt;span th:text="${user.name}"&gt;&lt;/span&gt;&lt;br&gt;     用户年龄：&lt;span th:text="${user.age}"&gt;&lt;/span&gt;&lt;br&gt;  </code></pre><h3 id="2-2-2-选择变量表达式（了解）"><a href="#2-2-2-选择变量表达式（了解）" class="headerlink" title="2.2.2 选择变量表达式（了解）"></a>2.2.2 选择变量表达式（了解）</h3></li><li><p>语法：*{…}  </p></li><li><p>说明<br>选择变量表达式，也叫星号变量表达式，使用 th:object 属性来绑定对象<br>选择表达式首先使用 th:object 来绑定后台传来的 User 对象，然后使用 * 来代表这个对象，后面 {} 中的值是此对象中的属性。<br>选择变量表达式 *{…} 是另一种类似于标准变量表达式 ${…} 表示变量的方法<br>选择变量表达式在执行时是在选择的对象上求解，而${…}是在上下文的变量 Model 上求<br>解，这种写法比标准变量表达式繁琐，只需要大家了解即可  </p></li><li><p>代码  </p><pre><code>&lt;h1&gt;选择变量表达式(星号表达式)：*{} -&gt; 不推荐&lt;/h1&gt; &lt;div th:object="${user}"&gt;     用户标识:&lt;span th:text="*{id}"&gt;&lt;/span&gt;&lt;br&gt;     用户姓名：&lt;span th:text="*{name}"&gt;&lt;/span&gt;&lt;br&gt;     用户年龄：&lt;span th:text="*{age}"&gt;&lt;/span&gt;&lt;br&gt; &lt;/div&gt;</code></pre><h3 id="2-2-3-标准变量表达式和选择变量表达式混合使用"><a href="#2-2-3-标准变量表达式和选择变量表达式混合使用" class="headerlink" title="2.2.3 标准变量表达式和选择变量表达式混合使用"></a>2.2.3 标准变量表达式和选择变量表达式混合使用</h3><p>标准变量和选择变量表达式可以混合使用，也可以不混合使用，使用 th:object 进行对<br>象的选择，也可以直接使用 *{…} 获取数据</p></li><li><p>代码  </p><pre><code>&lt;h1&gt;标签变量表达式与选择变量表达式的混合使用（不推荐）&lt;/h1&gt;用户标识:&lt;span th:text="*{user.id}"&gt;&lt;/span&gt;&lt;br&gt;用户姓名：&lt;span th:text="*{user.name}"&gt;&lt;/span&gt;&lt;br&gt;用户年龄：&lt;span th:text="*{user.age}"&gt;&lt;/span&gt;&lt;br&gt;</code></pre><h3 id="2-2-4-URL表达式"><a href="#2-2-4-URL表达式" class="headerlink" title="2.2.4 URL表达式"></a>2.2.4 URL表达式</h3></li><li><p>语法@{……}  </p></li><li><p>说明<br>主要用于链接、地址的展示，可用于  </p><pre><code>&lt;script src="..."&gt;、&lt;link href="..."&gt;、&lt;a href="..."&gt;、&lt;form action="..."&gt;、&lt;img src=""&gt;等，可以在 URL 路径中动态获取数据  </code></pre></li><li><p>代码  </p></li></ol><ol><li><p>创建 url.html  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;url&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;URL路径表达式：@{……}&lt;/h1&gt; &lt;h2&gt;a标签中的绝对路径（没有参数）&lt;/h2&gt; &lt;a href="/index.do"&gt;传统写法，跳转到/index.do&lt;/a&gt;&lt;br&gt;  &lt;!-- http://localhost:8080/index.do--&gt; &lt;a th:href="@{http://www.baidu.com}"&gt;路径表达式，跳转到百度&lt;/a&gt;&lt;br&gt; &lt;a th:href="@{http://localhost:8080/test/index.do}"&gt;路径表达式，跳转到/index.do&lt;/a&gt;&lt;br&gt; &lt;a href="http://localhost:8080/test/index.do"&gt;传统写法，跳转到/index.do&lt;/a&gt;&lt;br&gt; &lt;h2&gt;URL路径表达式，相对路径[没有参数]（实际开发中推荐使用的）&lt;/h2&gt; &lt;a th:href="@{/index.do}"&gt;跳转到/index.do&lt;/a&gt;&lt;br&gt;  &lt;!--http://localhost:8080/test/index.do--&gt; &lt;h2&gt;绝对路径（带参数）（不推荐使用）&lt;/h2&gt; &lt;a href="http://localhost:8080/test/properties.do?name='lisi'"&gt;绝对路径，带参数：/test/properties.do,并带参数name&lt;/a&gt;&lt;br&gt; &lt;a th:href="@{http://localhost:8080/test/properties.do?name=lisi}"&gt;路径表达式写法，带参数：、test,并带参数name&lt;/a&gt;&lt;br&gt; &lt;h2&gt;相对路径（带参数）&lt;/h2&gt; &lt;a th:href="@{/properties.do?name=lisi}"&gt;相对路径，带参数&lt;/a&gt; &lt;h2&gt;相对路径（带参数：后台获取的参数值）&lt;/h2&gt; &lt;!--/properties.do?name=1001--&gt; &lt;a th:href="@{'/properties.do?name='+${username}}"&gt;相对路径（带参数：后台获取的参数值）&lt;/a&gt; &lt;h2&gt;相对路径（带多个参数：后台获取的参数值）&lt;/h2&gt; &lt;!--     /test.do?id=1001&amp;username=zhangsan&amp;age=25 --&gt; &lt;a th:href="@{'/test.do?id='+${id}+'&amp;username='+${username}+'&amp;age='+${age}}"&gt;相对路径（带多个参数：后台获取的参数值）&lt;/a&gt;&lt;br&gt; &lt;a th:href="@{/test.do(id=${id},username=${username},age=${age})}"&gt;强烈推荐-相对路径（带多个参数：后台获取的参数值）&lt;/a&gt;&lt;br&gt; &lt;a th:href="@{'/test1.do/'+${id}}"&gt;请求路径为RSTEful风格&lt;/a&gt;&lt;br&gt; &lt;a th:href="@{'/test2.do/'+${id}+'/'+${username}}"&gt;请求路径为RSTEful风格&lt;/a&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>为了演示加上下文的效果，在 application.properties 中配置项目上下文   </p><pre><code>#设置上下文根server.servlet.context-path=/test/#设置缓存spring.thymeleaf.cache=false#可选spring.thymeleaf.mode=HTMLspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html</code></pre></li><li><p>在 ThymeleafController 中添加如下方法：  </p><pre><code> @Controller public class ThymeleafController {     @RequestMapping(value = "/index.do")     public String index(Model model){         User user = new User();         user.setId(1001);         user.setName("zhangsan");         user.setAge(21);         model.addAttribute("user",user);         return "index";     }     @RequestMapping(value = "/properties.do")     public @ResponseBody     String index(String name){         return "properties"+name;     }     @RequestMapping(value = "/url.do")     public String indexs(Model model){         model.addAttribute("id",1001);         model.addAttribute("username","zhangsan");         model.addAttribute("age",25);         return "url";     }     public @ResponseBody Object index(Integer id,String username,Integer age){         return "路径表达式：相对路径 id="+id+",username="+username+",age="+age;     }     @RequestMapping(value = "test1.do/{id}")     public @ResponseBody String index1(@PathVariable("id") Integer id){         return "ID:"+id;     }     @RequestMapping(value = "test2.do/{id}/{username}")     public @ResponseBody String index2(@PathVariable("id") Integer id,                                     @PathVariable("username") String username){         return "ID:"+id+"-------------"+"username:"+username;     } }</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot&amp;Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot使用拦截器</title>
      <link href="post/d8b4.html"/>
      <url>post/d8b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot使用拦截器"><a href="#SpringBoot使用拦截器" class="headerlink" title="SpringBoot使用拦截器"></a>SpringBoot使用拦截器</h1><h2 id="1-1-回顾SpringMVC使用拦截器步骤"><a href="#1-1-回顾SpringMVC使用拦截器步骤" class="headerlink" title="1.1 回顾SpringMVC使用拦截器步骤"></a>1.1 回顾SpringMVC使用拦截器步骤</h2><ul><li><p>自定义拦截器类，实现HandlerInterceptor接口  </p></li><li><p>注册拦截器类  </p><pre><code>&lt;!--声明拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;!--声明第一个拦截器--&gt;    &lt;mvc:interceptor&gt;        &lt;!--指定拦截器的拦截地址            path：拦截的uri地址，使用 ** 通配符。                例如： path="/user/**"                http://localhost:8080/user/listUser.do                http://localhost:8080/user/query/queryUser.do        --&gt;        &lt;mvc:mapping path="/**"/&gt;        &lt;!--指定使用的拦截器--&gt;        &lt;bean class="com.bjpowernode.handler.MyInterceptor"/&gt;    &lt;/mvc:interceptor&gt;  &lt;/mvc:interceptors&gt;  </code></pre></li><li><p>按照 SpringMVC 方式编写一个拦截器类，实现 HandlerInterceptor 接口  </p><pre><code>public class LoginInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //判断用户是否登入，没有登入，重定向到登入页面，不放行。登录就放行        String uri = request.getRequestURI();        System.out.println(uri);        //判断当前请求地址是否登录地址        if (uri.contains("Login") || uri.contains("login")){            //登录请求，直接发行            return true;        }else {            //判断用户是否登录            if (request.getSession().getAttribute(SysConfig.USER_CONTEXT)!=null){                //说明已经登录，发行                return true;            }else {                //没有登录，跳转到登录页面                response.sendRedirect(request.getContextPath()+"/index.jsp");            }        }        //默认拦截        return false;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><h2 id="1-2-SpringBoot使用拦截器步骤"><a href="#1-2-SpringBoot使用拦截器步骤" class="headerlink" title="1.2 SpringBoot使用拦截器步骤"></a>1.2 SpringBoot使用拦截器步骤</h2><h3 id="1-2-1-实现一个登录拦截器"><a href="#1-2-1-实现一个登录拦截器" class="headerlink" title="1.2.1 实现一个登录拦截器"></a>1.2.1 实现一个登录拦截器</h3></li></ul><ol><li><p>定义一个拦截器，实现HandlerInterceptor接口  </p><pre><code>public class UserInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //编写业务拦截的规则        //从session中获取用户的信息        User user = (User) request.getSession().getAttribute("user");        //判断用户是否登录        if (null == user){            //未登录，跳转到登录页面            response.sendRedirect(request.getContextPath()+"/login");            return false;        }        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre></li><li><p>创建一个配置类（即：在SpringMVC配置文件中使用mvc:interceptors标签）  </p><blockquote><p>在 项 目 中 创 建 一 个 config 包 ， 创 建 一 个 配 置InterceptorConfig ， 并 实 现WebMvcConfigurer 接口， 覆盖接口中的 addInterceptors 方法，并为该配置类添加@Configuration 注解，标注此类为一个配置类，让 Spring Boot 扫描到，这里的操作就相当于 SpringMVC 的注册拦截器 ，@Configuration 就相当于一个 applicationContext-mvc.xml</p></blockquote><pre><code>@Configuration  //定义此类为配置文件（即相当于SpringMVC的xml配置文件）public class InterceptorConfig implements WebMvcConfigurer {    //要拦截user下的所有访问请求，必须用户登录后才可访问    String[] addPathPatterns = {            "/user/**"    };    //跳过所拦截的路径,不需要用户登录也可访问    String[] excludePathPatterns = {            "/user/login","/user/index","/user/error"    };    //mvc:interceptors    @Override    public void addInterceptors(InterceptorRegistry registry) {        //声明第一个拦截器        //&lt;mvc:interceptor &lt;bean class/&gt; &lt;mvc:mapping path/&gt; &lt;mvc:exclude-mapping path/&gt;        //&lt;bean class/&gt;: new UserInterceptor() 指定使用的拦截器        //&lt;mvc:mapping path/&gt; : addPathPatterns() 指定拦截器拦截地址        //&lt;mvc:exclude-mapping path/&gt; : excludePathPatterns() 指定拦截器跳过拦截地址        registry.addInterceptor(new UserInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns);    }}</code></pre></li><li><p>创建一个控制层  </p><pre><code>@Controller@RequestMapping(value = "/user")public class UserController {    //用户登录的请求    @RequestMapping(value = "/login")    public @ResponseBody Object login(HttpServletRequest request){        //将用户的信息存放到session中        User user = new User();        user.setId(1001);        user.setName("zhangsan");        request.getSession().setAttribute("user",user);        return "login SUCCESS";    }    //该请求需要用户登录成功才可访问    @RequestMapping(value = "/center")    public @ResponseBody Object center(){        return "center SUCCESS";    }    //该请求不登录也可访问    @RequestMapping(value = "/index")    public @ResponseBody Object index(){        return "index SUCCESS";    }    //如果用户未登录访问了需要登录才可访问的请求，之后会跳转到该请求路径    @RequestMapping(value = "/error")    public @ResponseBody Object error(){        return "error SUCCESS";    }}</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成Dubbo+Redis+SSM</title>
      <link href="post/bd1.html"/>
      <url>post/bd1.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot集成Dubbo-Redis-SSM"><a href="#SpringBoot集成Dubbo-Redis-SSM" class="headerlink" title="SpringBoot集成Dubbo+Redis+SSM"></a>SpringBoot集成Dubbo+Redis+SSM</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="1-接口工程：存放实体bean和业务接口"><a href="#1-接口工程：存放实体bean和业务接口" class="headerlink" title="1.接口工程：存放实体bean和业务接口"></a>1.接口工程：存放实体bean和业务接口</h3><ul><li><p><strong>1. 实体 bean 必须实现序列化</strong>  </p><pre><code>package com.jxgm.springboot.model;import java.io.Serializable;public class Student implements Serializable {    private Integer id;    private String name;    private Integer age;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre></li><li><p><strong>2. 创建 StudentService 业务接口类</strong>  </p><pre><code>public interface StudentService {    //通过id获取信息    Student queryStudentById(Integer id);    //获取学生总人数    Integer queryAllStudentCount();}</code></pre><h3 id="2-服务提供者：它是一个SpringBoot框架web项目，集成MyBatis-Redis"><a href="#2-服务提供者：它是一个SpringBoot框架web项目，集成MyBatis-Redis" class="headerlink" title="2.服务提供者：它是一个SpringBoot框架web项目，集成MyBatis,Redis"></a>2.服务提供者：它是一个SpringBoot框架web项目，集成MyBatis,Redis</h3></li><li><p><strong>添加依赖：MyBatis依赖，MySQL驱动，Dubbo依赖，zookeeper依赖，Redis依赖，接口工程</strong>  </p><pre><code>&lt;dependencies&gt;    &lt;!--springboot框架web项目起步依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--mybatis集成springboot依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--dubbo集成springboot依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--注册中心--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.101tec&lt;/groupId&gt;        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;        &lt;version&gt;0.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--springboot集成redis依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--接口工程--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.jxgm.springboot&lt;/groupId&gt;        &lt;artifactId&gt;020-springboot-integration-interface&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;plugins&gt;        &lt;!--mybatis 代码自动生成插件--&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.6&lt;/version&gt;            &lt;configuration&gt;                &lt;!--配置文件的位置--&gt;                &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt;                &lt;verbose&gt;true&lt;/verbose&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><ul><li><strong>配置mybatis逆向工程(生成实体bean,mapper映射文件，接口)</strong>  </li></ul><p>  <strong>mapper接口</strong></p><pre><code>package com.jxgm.springboot.mapper;import com.jxgm.springboot.model.Student;public interface StudentMapper {    int deleteByPrimaryKey(Integer id);    int insert(Student record);    int insertSelective(Student record);    Student selectByPrimaryKey(Integer id);    int updateByPrimaryKeySelective(Student record);    int updateByPrimaryKey(Student record);    //查询学生总人数    Integer selectAllStudentCount();}</code></pre><p>  <strong>mapper映射文件</strong>  </p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.jxgm.springboot.mapper.StudentMapper"&gt;    &lt;resultMap id="BaseResultMap" type="com.jxgm.springboot.model.Student"&gt;        &lt;id column="id" jdbcType="INTEGER" property="id"/&gt;        &lt;result column="name" jdbcType="VARCHAR" property="name"/&gt;        &lt;result column="age" jdbcType="INTEGER" property="age"/&gt;    &lt;/resultMap&gt;    &lt;sql id="Base_Column_List"&gt;    id, name, age&lt;/sql&gt;    &lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt;        select        &lt;include refid="Base_Column_List"/&gt;        from t_student        where id = #{id,jdbcType=INTEGER}    &lt;/select&gt;    &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer"&gt;    delete from t_student    where id = #{id,jdbcType=INTEGER}&lt;/delete&gt;    &lt;insert id="insert" parameterType="com.jxgm.springboot.model.Student"&gt;    insert into t_student (id, name, age    )    values (#{id,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER}    )&lt;/insert&gt;    &lt;insert id="insertSelective" parameterType="com.jxgm.springboot.model.Student"&gt;        insert into t_student        &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt;            &lt;if test="id != null"&gt;                id,            &lt;/if&gt;            &lt;if test="name != null"&gt;                name,            &lt;/if&gt;            &lt;if test="age != null"&gt;                age,            &lt;/if&gt;        &lt;/trim&gt;        &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt;            &lt;if test="id != null"&gt;                #{id,jdbcType=INTEGER},            &lt;/if&gt;            &lt;if test="name != null"&gt;                #{name,jdbcType=VARCHAR},            &lt;/if&gt;            &lt;if test="age != null"&gt;                #{age,jdbcType=INTEGER},            &lt;/if&gt;        &lt;/trim&gt;    &lt;/insert&gt;    &lt;update id="updateByPrimaryKeySelective" parameterType="com.jxgm.springboot.model.Student"&gt;        update t_student        &lt;set&gt;            &lt;if test="name != null"&gt;                name = #{name,jdbcType=VARCHAR},            &lt;/if&gt;            &lt;if test="age != null"&gt;                age = #{age,jdbcType=INTEGER},            &lt;/if&gt;        &lt;/set&gt;        where id = #{id,jdbcType=INTEGER}    &lt;/update&gt;    &lt;update id="updateByPrimaryKey" parameterType="com.jxgm.springboot.model.Student"&gt;    update t_student    set name = #{name,jdbcType=VARCHAR},    age = #{age,jdbcType=INTEGER}    where id = #{id,jdbcType=INTEGER}&lt;/update&gt;&lt;!-- 查询学生总人数 --&gt;&lt;select id="selectAllStudentCount" resultType="Integer"&gt;    select count(*) from t_student&lt;/select&gt;&lt;/mapper&gt;</code></pre><ul><li><p><strong>配置SpringBoot核心配置文件</strong></p></li><li><p><strong>配置连接数据库</strong></p></li><li><p><strong>配置连接redis</strong></p></li><li><p><strong>配置dubbo</strong>  </p><pre><code>#设置内嵌Tomcat端口号server.port=8888#设置上下文根server.servlet.context-path=/#mysql数据库连接信息spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=213145#redis数据库连接信息spring.redis.host=192.168.213.145spring.redis.port=6379spring.redis.password=#配置Dubbospring.application.name=021-springboot-integration-provide#当前工程是一个服务提供者spring.dubbo.server=true#设置注册中心spring.dubbo.registry=zookeeper://192.168.213.145:2181</code></pre></li><li><p><strong>配置启动类</strong>  </p><pre><code>@SpringBootApplication@MapperScan(basePackages = "com.jxgm.springboot.mapper")@EnableDubboConfiguration //开启dubbo配置public class Application {  public static void main(String[] args) {      SpringApplication.run(Application.class, args);  }}</code></pre></li><li><p><strong>创建StudentServiceImpl 业务接口实现类</strong></p><pre><code>@Component@Service(interfaceName = "com.jxgm.springboot.service.StudentService",version = "1.0.0" , timeout = 15000)public class StudentServiceImpl implements StudentService {  @Autowired  private StudentMapper studentMapper;  @Autowired  private RedisTemplate&lt;Object,Object&gt; redisTemplate;  @Override  public Student queryStudentById(Integer id) {      return studentMapper.selectByPrimaryKey(id);  }  @Override  public Integer queryAllStudentCount() {      //提升系统性能，用户体验提升      //首先去redis缓存中查询，如果有：直接使用，如果没有：去数据库查询并存放到redis缓存中      Integer allStudentCount = (Integer) redisTemplate.opsForValue().get("allStudentCount");        //判断redis缓存中是否有值      if (null == allStudentCount){      // 去数据库查询      allStudentCount = studentMapper.selectAllStudentCount();        //并放入redis缓存中      redisTemplate.opsForValue().set("allStudentCount",allStudentCount,120, TimeUnit.SECONDS);        }        return allStudentCount;  }}</code></pre></li></ul></li></ul><h3 id="3-服务消费者：它是一个SpringBoot框架web项目，集成JSP-Dubbo"><a href="#3-服务消费者：它是一个SpringBoot框架web项目，集成JSP-Dubbo" class="headerlink" title="3.服务消费者：它是一个SpringBoot框架web项目，集成JSP,Dubbo"></a>3.服务消费者：它是一个SpringBoot框架web项目，集成JSP,Dubbo</h3><ul><li><p><strong>添加依赖：Dubbo依赖，zookeeper依赖，解析JSP页面的依赖，接口工程</strong>  </p><pre><code>&lt;dependencies&gt;    &lt;!--springboot框架web项目起步依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--dubbo集成springboot依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--注册中心--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.101tec&lt;/groupId&gt;        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;        &lt;version&gt;0.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--接口工程--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.jxgm.springboot&lt;/groupId&gt;        &lt;artifactId&gt;020-springboot-integration-interface&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--引入SpringBoot内嵌Tomcat对jsp的解析依赖，不添加的话解析不了jsp--&gt;    &lt;!--仅仅只是展示jsp页面，只添加以下一个依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;!--       SpringBoot项目默认推荐使用的前端引擎是thymeleaf       现在我们要使用springBoot集成jsp，手动指定jsp最后编译的路径       而且SpringBoot集成jsp编译jsp的路径是SpringBoot规定好的位置       META-INF/resources   --&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;!--源文件--&gt;            &lt;directory&gt;src/main/webapp&lt;/directory&gt;            &lt;!--指定编译到META-INF/resources--&gt;            &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;            &lt;!--指定源文件夹中的哪个资源要编译进行--&gt;            &lt;includes&gt;                &lt;include&gt;*.*&lt;/include&gt;            &lt;/includes&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;</code></pre><ul><li><p><strong>配置SpringBoot核心配置文件</strong></p></li><li><p><strong>配置视图解析器</strong></p></li><li><p><strong>配置dubbo</strong>  </p><pre><code>#设置内嵌Tomcat端口号server.port=8090#设置上下文根server.servlet.context-path=/#视图解析器spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp#配置dubbospring.application.name=022-springboot-integration-consumer#注册中心spring.dubbo.registry=zookeeper://192.168.213.145:2181</code></pre></li><li><p><strong>配置启动类</strong>  </p><pre><code>@SpringBootApplication@EnableDubboConfigurationpublic class Application {  public static void main(String[] args) {      SpringApplication.run(Application.class, args);  }}</code></pre></li><li><p><strong>StudentController控制层</strong>  </p></li></ul><p>  <strong>在服务消费者项目中添加StudentController类</strong>  </p><pre><code>@Controllerpublic class StudentController {    @Reference(interfaceName = "com.jxgm.springboot.service.StudentService",version = "1.0.0",check = false)    private StudentService studentService;    @RequestMapping(value = "/student/detail/{id}")    public String studentDetail(Model model,@PathVariable("id") Integer id){          Student student = studentService.queryStudentById(id);          model.addAttribute("student",student);          return "studentDetail";    }    @GetMapping(value = "/student/all/count")    public @ResponseBody Object queryAllStudentCount(){          Integer count = studentService.queryAllStudentCount();          return "学生总人数："+count;      }}</code></pre><ul><li><strong>创建jsp</strong><pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;学生信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div align="center"&gt;      &lt;h1&gt;学生信息&lt;/h1&gt;      &lt;h3&gt;学生标识:${student.id}&lt;/h3&gt;      &lt;h3&gt;学生姓名:${student.name}&lt;/h3&gt;      &lt;h3&gt;学生年龄:${student.age}&lt;/h3&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="4-启动浏览器进行测试"><a href="#4-启动浏览器进行测试" class="headerlink" title="4.启动浏览器进行测试"></a>4.启动浏览器进行测试</h2></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot框架Web开发</title>
      <link href="post/858e.html"/>
      <url>post/858e.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot框架Web开发"><a href="#SpringBoot框架Web开发" class="headerlink" title="SpringBoot框架Web开发"></a>SpringBoot框架Web开发</h1><h2 id="3-1-Spring-Boot-集成-MyBatis"><a href="#3-1-Spring-Boot-集成-MyBatis" class="headerlink" title="3.1 Spring Boot 集成 MyBatis"></a>3.1 Spring Boot 集成 MyBatis</h2><h3 id="3-1-1-案例"><a href="#3-1-1-案例" class="headerlink" title="3.1.1 案例"></a>3.1.1 案例</h3><ul><li><strong>通过SpringBoot+MyBatis实现对数据库学生表的查询操作</strong>  </li></ul><ol><li><p><strong>准备数据库</strong><br>sql脚本 </p><pre><code>drop table if exists t_student;create table t_student (id                   int(10)                        not null auto_increment,name                 varchar(20)                    null,age                  int(10)                        null,constraint PK_T_STUDENT primary key clustered (id));  insert into t_student(name,age) values("zhangsan",25);  insert into t_student(name,age) values("lisi",28);  insert into t_student(name,age) values("wangwu",23);  insert into t_student(name,age) values("Tom",21);  insert into t_student(name,age) values("Jck",55);  insert into t_student(name,age) values("Lucy",27);  insert into t_student(name,age) values("zhaoliu",75);   </code></pre></li><li><p><strong>创建新的SpringBoot项目</strong>  </p></li><li><p><strong>在pom.xml中添加相关的jar依赖</strong>  </p><pre><code>&lt;!--Mysql驱动--&gt;     &lt;dependency&gt;         &lt;groupId&gt;mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!--Mybatis整合SpringBoot框架的起步依赖--&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;         &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;         &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ol><h2 id="13-1-SpringBoot-工程中使用MyBatis反向工程"><a href="#13-1-SpringBoot-工程中使用MyBatis反向工程" class="headerlink" title="13.1 SpringBoot 工程中使用MyBatis反向工程"></a>13.1 SpringBoot 工程中使用MyBatis反向工程</h2><h3 id="13-1-1-创建MyBatis反向工程配置文件导项目的根目录下"><a href="#13-1-1-创建MyBatis反向工程配置文件导项目的根目录下" class="headerlink" title="13.1.1 创建MyBatis反向工程配置文件导项目的根目录下"></a>13.1.1 创建MyBatis反向工程配置文件导项目的根目录下</h3><p>创建目录：GeneratorMapper.xml  </p><h3 id="13-1-2-根据项目及表的情况，修改-GeneratorMapper-xml配置"><a href="#13-1-2-根据项目及表的情况，修改-GeneratorMapper-xml配置" class="headerlink" title="13.1.2 根据项目及表的情况，修改 GeneratorMapper.xml配置"></a>13.1.2 根据项目及表的情况，修改 GeneratorMapper.xml配置</h3><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;    &lt;!-- 指定连接数据库的 JDBC 驱动包所在位置，指定到你本机的完整路径 --&gt;    &lt;classPathEntry location="D:\Java\Maven\repository\mysql\mysql-connector-java\8.0.25\mysql-connector-java-8.0.25.jar"/&gt;    &lt;!-- 配置 table 表信息内容体，targetRuntime 指定采用 MyBatis3 的版本 --&gt;    &lt;context id="tables" targetRuntime="MyBatis3"&gt;        &lt;!-- 抑制生成注释，由于生成的注释都是英文的，可以不让它生成 --&gt;        &lt;commentGenerator&gt;            &lt;property name="suppressAllComments" value="true" /&gt;        &lt;/commentGenerator&gt;        &lt;!-- 配置数据库连接信息 --&gt;        &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver"                        connectionURL="jdbc:mysql://localhost:3306/springboot"                        userId="root"                        password="213145"&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 生成 model 类，targetPackage 指定 model 类的包名， targetProject 指定       生成的 model 放在 idea 的哪个工程下面--&gt;        &lt;javaModelGenerator targetPackage="com.jxgm.springboot.model"                            targetProject="src/main/java"&gt;            &lt;property name="enableSubPackages" value="false" /&gt;            &lt;property name="trimStrings" value="false" /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 生成 MyBatis 的 Mapper.xml 文件，targetPackage 指定 mapper.xml 文件的       包名， targetProject 指定生成的 mapper.xml 放在 idea 的哪个工程下面 --&gt;        &lt;sqlMapGenerator targetPackage="com.jxgm.springboot.mapper"                         targetProject="src/main/java"&gt;            &lt;property name="enableSubPackages" value="false" /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 生成 MyBatis 的 Mapper 接口类文件,targetPackage 指定 Mapper 接口类的包       名， targetProject 指定生成的 Mapper 接口放在 idea 的哪个工程下面 --&gt;        &lt;javaClientGenerator type="XMLMAPPER"                             targetPackage="com.jxgm.springboot.mapper" targetProject="src/main/java"&gt;            &lt;property name="enableSubPackages" value="false" /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 数据库表名及对应的 Java 模型类名 --&gt;        &lt;table tableName="t_student" domainObjectName="Student"               enableCountByExample="false"               enableUpdateByExample="false"               enableDeleteByExample="false"               enableSelectByExample="false"               selectByExampleQueryId="false"/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;  </code></pre><ul><li>注意  <blockquote><p>如果使用高版本，驱动类变为：com.mysql.cj.jdbc.Driver<br>url后面应该加属性 nullCatalogMeansCurrent=true,否则生成有问题  </p></blockquote><h3 id="13-1-3-在pom-xml文件中-mysql-反向工程依赖"><a href="#13-1-3-在pom-xml文件中-mysql-反向工程依赖" class="headerlink" title="13.1.3 在pom.xml文件中 mysql 反向工程依赖"></a>13.1.3 在pom.xml文件中 mysql 反向工程依赖</h3></li><li>在pom.xml文件 build 中添加  </li></ul><pre><code> &lt;!--mybatis 代码自动生成插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.6&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置--&gt;                    &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;  </code></pre><h3 id="13-1-4-使用MyBatis提供的逆向工程，生成实体bean-映射文件，Dao接口"><a href="#13-1-4-使用MyBatis提供的逆向工程，生成实体bean-映射文件，Dao接口" class="headerlink" title="13.1.4 使用MyBatis提供的逆向工程，生成实体bean,映射文件，Dao接口"></a>13.1.4 使用MyBatis提供的逆向工程，生成实体bean,映射文件，Dao接口</h3><p><strong>点击idea右侧maven按钮，下拉当前工程-&gt;下拉Plugins-&gt;下拉mybatis-generator-&gt;双击mybatis-generator:generate运行，生成相关文件</strong>  </p><ol><li><strong>在SpringBoot的核心配置文件 application.properties中配置数据源</strong>  <blockquote><p>#数据库连接信息<br>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8<br>spring.datasource.username=root<br>spring.datasource.password=213145  </p></blockquote></li><li><strong>开发代码</strong></li></ol><ul><li>使用MyBatis反向工程生成接口、映射文件以及实体bean。</li><li>编写Service业务层</li><li>编写Controller控制层</li><li>在MyBatis反向工程生成的 Mapper接口上加一个Mapper注解<br>@Mapper作用：mybatis自动扫描数据持久层的映射文件及DAO接口的关系  <h3 id="3-2-2-DAO其他开发方式"><a href="#3-2-2-DAO其他开发方式" class="headerlink" title="3.2.2 DAO其他开发方式"></a>3.2.2 DAO其他开发方式</h3></li></ul><ol><li><strong>在运行的主类上添加注解包扫描</strong>  <pre><code>@SpringBootApplication  //开启spring配置   //MyBatis提供的注解：扫描数据持久层的mapper映射配置文件，DAO接口上就不用加@Mapper   //basePackages 通常指定到数据持久层的包即可 @MapperScan(basePackages = "com.jxgm.springboot.mapper") //开启扫描Mapper接口的包以及子目录   public class Application {     public static void main(String[] args) {       SpringApplication.run(Application.class, args);       }    }</code></pre></li><li><strong>将接口和映射文件分开</strong><br>因为SpringBoot不能自动编译接口的映射文件，还需要手动在pom文件中指定，有些公司直接将映射文件直接放到resources目录下  </li></ol><ul><li>在resources目录下新建目录mapper存放映射文件，将StudentMapper.xml文件移到resource/mapper目录下  </li><li>在application.properties配置文件中指定映射文件的位置，这个配置只有接口和映射文件不在同一个包的情况下，才需要指定  <blockquote><p>#指定MyBatis映射文件的路径<br>  mybatis.mapper-locations=classpath:mapper/StudentMapper.xml<br>  #mybatis.mapper-locations=classpath:mapper/*.xml  </p></blockquote></li></ul><h2 id="3-3-SpringBoot项目下使用事务"><a href="#3-3-SpringBoot项目下使用事务" class="headerlink" title="3.3 SpringBoot项目下使用事务"></a>3.3 SpringBoot项目下使用事务</h2><ul><li>事务是一个完整的功能，也叫做是一个完整的业务，事务只跟DML语句有关系：增删改  </li></ul><p><strong>SpringBoot使用事务非常简单，底层依然采用的是Spring本身提供的事务管理</strong>  </p><ul><li>在入口类中使用注解 @EnableTransactionManagement 开启事务支持  </li><li>在访问数据库的Service 方法上添加注解 @Transactional即可  <h2 id="3-4-SpringBoot下的SpringMVC"><a href="#3-4-SpringBoot下的SpringMVC" class="headerlink" title="3.4 SpringBoot下的SpringMVC"></a>3.4 SpringBoot下的SpringMVC</h2>  SpringBoot 下的SpringMVC和之前的SpringMVC使用是完全一样的，主要有以下注解  <h3 id="3-4-1-Controller"><a href="#3-4-1-Controller" class="headerlink" title="3.4.1 @Controller"></a>3.4.1 @Controller</h3>  SpringMVC的注解，处理http请求  <h3 id="3-4-2-RestController"><a href="#3-4-2-RestController" class="headerlink" title="3.4.2 @RestController"></a>3.4.2 @RestController</h3>  Spring4 后新增注解，是@Controller注解功能的增强<br>  是@Controller与@ResponseBody的组合注解<br>  如果一个Controller类添加了@RestController，那么该Controller类下的所有方法都相当于添加了@ResponseBody注解<br>  用于返回字符串或json数据  <h3 id="3-4-3-RequestMapping-常用"><a href="#3-4-3-RequestMapping-常用" class="headerlink" title="3.4.3 @RequestMapping(常用)"></a>3.4.3 @RequestMapping(常用)</h3>  支持Get请求，也支持Post请求  <h3 id="3-4-4-GetMapping"><a href="#3-4-4-GetMapping" class="headerlink" title="3.4.4 @GetMapping"></a>3.4.4 @GetMapping</h3>  RequestMapping和Get请求方法的组合<br>  只支持Get请求<br>  Get请求主要用于查询操作  <h3 id="3-4-5-PostMapping"><a href="#3-4-5-PostMapping" class="headerlink" title="3.4.5 @PostMapping"></a>3.4.5 @PostMapping</h3>  RequestMapping和Post请求方法的组合<br>  只支持Post请求<br>  Post请求主要用于新增数据  <h3 id="3-4-6-PutMapping"><a href="#3-4-6-PutMapping" class="headerlink" title="3.4.6 @PutMapping"></a>3.4.6 @PutMapping</h3>  RequestMapping 和 Put请求方法的组合<br>  只支持Put请求<br>  Put通常用于修改数据  <h3 id="3-4-7-DeleteMapping"><a href="#3-4-7-DeleteMapping" class="headerlink" title="3.4.7 @DeleteMapping"></a>3.4.7 @DeleteMapping</h3>  RequestMapping 和 Delete请求方法的组合<br>  只支持Delete请求<br>  通常用于删除数据  <h2 id="3-5-SpringBoot-实现-RESTful"><a href="#3-5-SpringBoot-实现-RESTful" class="headerlink" title="3.5 SpringBoot 实现 RESTful"></a>3.5 SpringBoot 实现 RESTful</h2><h3 id="3-5-1-认识-RESTful"><a href="#3-5-1-认识-RESTful" class="headerlink" title="3.5.1 认识 RESTful"></a>3.5.1 认识 RESTful</h3></li><li><strong>REST（英文：Representational State Transfer，简称 REST）</strong><br>一种互联网软件架构设计的风格，但它并不是标准，它只是提出了一组客户端和服务器<br>交互时的架构理念和设计原则，基于这种理念和原则设计的接口可以更简洁，更有层次，REST<br>这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。<br>任何的技术都可以实现这种理念，如果一个架构符合 REST 原则，就称它为 RESTFul 架<br>构<br>比如我们要访问一个 http 接口：<a href="http://localhost:8080/boot/order?id=1021&amp;status=1">http://localhost:8080/boot/order?id=1021&amp;status=1</a><br>采用 RESTFul 风格则 http 地址为：<a href="http://localhost:8080/boot/order/1021/1">http://localhost:8080/boot/order/1021/1</a>  <h3 id="3-5-2-Spring-Boot-开发-RESTFul"><a href="#3-5-2-Spring-Boot-开发-RESTFul" class="headerlink" title="3.5.2 Spring Boot 开发 RESTFul"></a>3.5.2 Spring Boot 开发 RESTFul</h3>Spring boot 开发 RESTFul 主要是几个注解实现  </li></ul><ol><li>@PathVariable  </li></ol><p><strong>获取 url 中的数据</strong><br>该注解是实现 RESTFul 最主要的一个注解<br>2. @PostMapping<br><strong>接收和处理 Post 方式的请求</strong><br>3. @DeleteMapping<br><strong>接收 delete 方式的请求，可以使用 GetMapping 代替</strong><br>4. @PutMapping<br><strong>接收 put 方式的请求，可以用 PostMapping 代替</strong><br>5. @GetMapping<br><strong>接收 get 方式的请求</strong>  </p><pre><code>@RestControllerpublic class IndexController {    @GetMapping("/student/g/{id}")    public Object selectStudent(@PathVariable("id") Integer id){        return "查询的id="+id;    }}</code></pre><h3 id="3-5-3-RESTful原则"><a href="#3-5-3-RESTful原则" class="headerlink" title="3.5.3 RESTful原则"></a>3.5.3 RESTful原则</h3><ul><li>增Post请求、删delete请求、改put请求、查get请求  </li><li><strong>请求路径不要出现动词</strong><br>  例如：查询订单接口<br>  /boot/order/1021/1(推荐)<br>  /boot/queryOrder/1021/1（不推荐）  </li><li><strong>分页、排序等操作，不需要使用斜杠传参数</strong><br>  例如：订单列表接口<br>  /boot/orders?page=1&amp;sort=desc<br>  一般传的参数不是数据库表的字段，可以采用斜杠  <h2 id="3-6-SpringBoot-集成-Redis"><a href="#3-6-SpringBoot-集成-Redis" class="headerlink" title="3.6 SpringBoot 集成 Redis"></a>3.6 SpringBoot 集成 Redis</h2></li></ul><ol><li><p>添加操作redis数据类型的依赖  </p><blockquote>  <!--SpringBoot集成Redis起步依赖--><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;  </code></pre></blockquote></li><li><p>在springboot核心配置文件中添加redis的配置  </p><blockquote><p> #配置redis数据库连接信息<br> spring.redis.host=192.168.213.145<br> spring.redis.port=6379<br> spring.redis.password=  </p></blockquote></li><li><p>redisController类  </p><pre><code>@Controllerpublic class StudentController { @Autowired private StudentService studentService; @RequestMapping(value = "/save/{key}/{value}") public @ResponseBody Object saveStudent(@PathVariable("key") String key,@PathVariable("value") String value){     Integer i = studentService.put(key, value);     return i==1?"添加数据到redis成功":"添加数据到redis失败"; } @RequestMapping(value = "/get/{key}") public @ResponseBody Object get(@PathVariable("key") String key){     String value = studentService.get(key);     return key+"的值为"+value; } @RequestMapping(value = "/del/{key}") public @ResponseBody Object del(@PathVariable("key") String key){     Integer del = studentService.del(key);     return del==1?key+"删除成功！":key+"删除失败！"; }}  </code></pre></li><li><p>StudentService接口  </p><pre><code>public interface StudentService { //将值放到redis中 Integer put(String key, String value); //从redis中获取指定的key的值 String get(String key); //从redis中删除指定的key Integer del(String key);}  </code></pre></li><li><p>在 StudentServiceImpl 中注入 RedisTemplate 并实现StudentService接口<br>配置了上面的步骤，SpringBoot将自动配置RedisTemplate，在需要操作redis的类中注入redisTemplate即可。<br>注意：<strong>SpringBoot帮我们注入RedisTemplate类，泛型里面只能写&lt;String,String&gt;、&lt;Object,Object&gt;或者什么都不写</strong>  </p><pre><code>@Servicepublic class StudentServiceImpl implements StudentService { @Autowired //获取redis对象模板 private RedisTemplate&lt;Object,Object&gt; redisTemplate; @Override public Integer put(String key, String value) {     //使用redis数据string类型，访问redis数据库     ValueOperations&lt;Object, Object&gt; opsForValue = redisTemplate.opsForValue();     opsForValue.set(key,value);     return 1; } @Override public String get(String key) {     ValueOperations&lt;Object, Object&gt; ops = redisTemplate.opsForValue();     String str = (String) ops.get(key);     return str; } @Override public Integer del(String key) {     Boolean delete = redisTemplate.delete(key);     if (delete){         return 1;     }     return 0; }}</code></pre></li><li><p>启动 SpringBoot 应用，访问测试   </p><h2 id="3-7-SpringBoot集成Dobbo分布式框架"><a href="#3-7-SpringBoot集成Dobbo分布式框架" class="headerlink" title="3.7 SpringBoot集成Dobbo分布式框架"></a>3.7 SpringBoot集成Dobbo分布式框架</h2></li></ol><ul><li><strong>面向接口编程</strong></li></ul><ol><li><p><strong>接口工程：存放实体bean和业务接口</strong>  </p><pre><code>public interface StudentService { Integer studentCount();}</code></pre></li><li><p><strong>服务提供者：业务接口的实现类并将服务暴露且注册到注册中心，使用业务层调用数据持久层</strong>  </p><ul><li><p>添加依赖（Dubbo，注册中心（zookeeper），接口工程）  </p><pre><code>&lt;!--Dubbo集成SpringBoot框架起步依赖--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.0.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--注册中心--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.101tec&lt;/groupId&gt;      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;      &lt;version&gt;0.10&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--接口工程--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.jxgm.springboot&lt;/groupId&gt;      &lt;artifactId&gt;017-springboo-interface&lt;/artifactId&gt;      &lt;version&gt;1.0.0&lt;/version&gt;  &lt;/dependency&gt;  </code></pre></li><li><p>配置服务提供者核心配置文件  </p><pre><code>#设置内嵌Tomcat端口号server.port=8888#设置上下文根server.servlet.context-path=/#设置dubbo的配置spring.application.name=018-springboot-provide#当前工程是一个服务提供者spring.dubbo.server=true#设置注册中心spring.dubbo.registry=zookeeper://192.168.213.145:2181</code></pre></li></ul></li><li><p><strong>服务消费者：处理浏览器客户端发送的请求，从注册中心调用服务提供者所提供的服务</strong>  </p><ul><li><p>添加依赖（Dubbo，注册中心（zookeeper），接口工程）  </p><pre><code>&lt;!--Dubbo集成SpringBoot框架起步依赖--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.0.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--注册中心--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.101tec&lt;/groupId&gt;      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;      &lt;version&gt;0.10&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--接口工程--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.jxgm.springboot&lt;/groupId&gt;      &lt;artifactId&gt;017-springboo-interface&lt;/artifactId&gt;      &lt;version&gt;1.0.0&lt;/version&gt;  &lt;/dependency&gt;</code></pre></li><li><p>配置服务消费者核心配置文件  </p><pre><code>#设置内嵌Tomcat端口server.port=8090#设置上下文根server.servlet.context-path=/#设置Dubbo配置spring.application.name=019-springboot-consumer#设置注册中心spring.dubbo.registry=zookeeper://192.168.213.145:2181</code></pre></li></ul></li><li><p><strong>在服务提供者项目中业务层，编写 Dubbo 的接口实现类</strong>  </p><pre><code>@Component//暴露服务接口@Service(interfaceClass = StudentService.class,version = "1.0.0",timeout = 15000)//&lt;dubbo:service interface="com.jxgm.springboot.service.StudentService" version="1.0.0" timeout="15000"/&gt;public class StudentServiceImpl implements StudentService {@Overridepublic Integer studentCount() {    //调用数据持久层    return 3000;    }}</code></pre></li><li><p><strong>在服务提供者项目中SpringBoot入口程序类上加开启 Dubbo 配置支持注解</strong>  </p><pre><code>@SpringBootApplication //开启spring注解配置@EnableDubboConfiguration //开启dubbo注解配置public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre></li><li><p><strong>在服务消费者项目中控制层，编写一个 Controller 类，调用远程的 Dubbo 服务</strong>  </p><pre><code>@Controllerpublic class DubboController {    //引用远程接口服务    //&lt;dubbo:reference interface="com.jxgm.springboot.service.StudentService" version="1.0.0" check=false/&gt;    //check = false 当服务消费者开启时不去检查提供者是否开启，只会在调用服务时再去检查    @Reference(interfaceClass = StudentService.class,version = "1.0.0",check = false)    private StudentService studentService;    @RequestMapping(value = "/dubbo/count")    public @ResponseBody Object dubbo(){        Integer num = studentService.studentCount();        return "学生总人数"+num;    }}</code></pre></li><li><p><strong>在服务消费者项目中SpringBoot入口程序类上加开启 Dubbo 配置支持注解</strong>  </p><pre><code>@SpringBootApplication //开启spring注解配置@EnableDubboConfiguration //开启dubbo注解配置public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre></li><li><p><strong>启动 Zookeeper 服务，启动浏览器进行测试</strong></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot入门</title>
      <link href="post/e10.html"/>
      <url>post/e10.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot框架入门"><a href="#SpringBoot框架入门" class="headerlink" title="SpringBoot框架入门"></a>SpringBoot框架入门</h1><h2 id="1-1-SpringBoot简介"><a href="#1-1-SpringBoot简介" class="headerlink" title="1.1 SpringBoot简介"></a>1.1 SpringBoot简介</h2><p>Spring Boot 是 Spring 家族中的一个全新的框架，它用来简化 Spring 应用程序的创建和开发过程，也可以说 Spring Boot 能简化我们之前采用 SpringMVC + Spring + MyBatis 框架进行开发的过程。  </p><p>在以往我们采用 SpringMVC + Spring + MyBatis 框架进行开发的时候，搭建和整合三大框架，我们需要做很多工作，比如配置 web.xml，配置 Spring，配置 MyBatis，并将它们整合在一起等，而 Spring Boot 框架对此开发过程进行了革命性的颠覆，完全抛弃了繁琐的 xml 配置过程，采用大量的默认配置简化我们的开发过程。</p><h2 id="1-2-SpringBoot的特性"><a href="#1-2-SpringBoot的特性" class="headerlink" title="1.2 SpringBoot的特性"></a>1.2 SpringBoot的特性</h2><ul><li><p><strong>能够快速创建基于Spring的应用程序</strong>  </p></li><li><p><strong>能够直接使用java.main方法启动内嵌的 Tomcat 服务器运行 SpringBoot程序，不需要部署war包文件</strong></p></li><li><p><strong>提供约定的 stater POM 来简化 Maven配置，让 Maven的配置变得简单</strong></p></li><li><p><strong>自动化配置，根据项目的 Maven依赖配置，SpringBoot自动配置 Spring、Springmvc等</strong></p></li><li><p><strong>提供了程序的健康检查等功能</strong></p></li><li><p><strong>基本可以完全不使用 XML配置文件，采用注解配置</strong>  </p><h2 id="1-3-SpringBoot四大核心"><a href="#1-3-SpringBoot四大核心" class="headerlink" title="1.3 SpringBoot四大核心"></a>1.3 SpringBoot四大核心</h2><h3 id="1-3-1-自动配置"><a href="#1-3-1-自动配置" class="headerlink" title="1.3.1 自动配置"></a>1.3.1 自动配置</h3><h3 id="1-3-2-起步依赖"><a href="#1-3-2-起步依赖" class="headerlink" title="1.3.2 起步依赖"></a>1.3.2 起步依赖</h3><h3 id="1-3-3-Actuator"><a href="#1-3-3-Actuator" class="headerlink" title="1.3.3 Actuator"></a>1.3.3 Actuator</h3><h3 id="1-3-4-命令行界面"><a href="#1-3-4-命令行界面" class="headerlink" title="1.3.4 命令行界面"></a>1.3.4 命令行界面</h3><h2 id="2-1-第一个SpringBoot项目"><a href="#2-1-第一个SpringBoot项目" class="headerlink" title="2.1 第一个SpringBoot项目"></a>2.1 第一个SpringBoot项目</h2><h3 id="2-1-1-项目结构"><a href="#2-1-1-项目结构" class="headerlink" title="2.1.1 项目结构"></a>2.1.1 项目结构</h3><blockquote><p>static：存放静态资源，如图片、CSS、JavaScript等<br>templates：存放Web页面的模板文件<br>application.properties/application.yml：用于存放程序各种依赖模块的配置信息，比如服务端口，数据库连接配置等。</p></blockquote><h3 id="2-1-2-对pom-xml文件进行解释"><a href="#2-1-2-对pom-xml文件进行解释" class="headerlink" title="2.1.2 对pom.xml文件进行解释"></a>2.1.2 对pom.xml文件进行解释</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!--继承 SpringBoot框架的一个父项目，所有自己开发的 SpringBoot都必须得继承--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.5.1&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--当前项目的 GAV 坐标--&gt;</span><br><span class="line">    &lt;groupId&gt;com.jxgm.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;001-springboot-first&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--编译级别--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--springBoot框架web项目起步依赖，通过该依赖自动关联其他依赖，不需要我们一个一个去添加了--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--springBoot框架的测试起步依赖，例如：junit 测试，如果不需要的话可以删除--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!--springBoot项目打包编译的插件--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-1-3-对SpringBoot项目结构进行说明"><a href="#2-1-3-对SpringBoot项目结构进行说明" class="headerlink" title="2.1.3 对SpringBoot项目结构进行说明"></a>2.1.3 对SpringBoot项目结构进行说明</h3></li><li><p><strong>mvn|mvnm|mvnw.cmd:使用脚本操作执行maven相关命令，国内使用较少，可删除</strong>  </p></li><li><p><strong>gitignore：使用版本控制工具git的时候，设置一些忽略提交的内容</strong></p></li><li><p><strong>static|templates：后面模板技术中存放文件的目录</strong>  </p></li><li><p><strong>application.properties：SpringBoot的配置文件，很多集成的配置都可以在该文件中进行配置，例如：Spring、SpringMVC、Mybatis、redis等。目前是空的</strong>  </p></li><li><p><strong>Application.java：SpringBoot程序执行的入口，执行该程序中的main方法，SpringBoot就启动了</strong>  </p><h3 id="2-2-1-使用SpringBoot框架集成SpringMVC"><a href="#2-2-1-使用SpringBoot框架集成SpringMVC" class="headerlink" title="2.2.1 使用SpringBoot框架集成SpringMVC"></a>2.2.1 使用SpringBoot框架集成SpringMVC</h3></li><li><p><strong>SpringBoot项目启动入口类 Application.java</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.jxgm.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">//SpringBoot项目启动入口类</span><br><span class="line">@SpringBootApplication  //开启SpringBoot配置</span><br><span class="line">public class Application {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //SpringBoot项目代码必须放在Application类所在的同级目录或者下级目录</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>IndexController类所在包com.jxgm.springboot.web</strong>  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.jxgm.springboot.web;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController {</span><br><span class="line">    @RequestMapping(value = "/springboot/say")</span><br><span class="line">    public @ResponseBody String say(){</span><br><span class="line">        return "Hello SpringBoot!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>注意：新建的类一定要位于Application同级目录或者下级目录，否则SpringBoot加载不到。</strong>  </p><h3 id="2-2-2-在-IDEA-中右键，运行-Application-类中的-main-方法"><a href="#2-2-2-在-IDEA-中右键，运行-Application-类中的-main-方法" class="headerlink" title="2.2.2 在 IDEA 中右键，运行 Application 类中的 main 方法"></a>2.2.2 在 IDEA 中右键，运行 Application 类中的 main 方法</h3><blockquote><p> Tomcat started on port(s): 8080 (http) with context path ‘ ‘<br>通过在控制台的输出，可以看到启动 SpringBoot 框架，会启动一个内嵌的 tomcat，端<br>口号为 8080，上下文根为空  </p></blockquote><h3 id="2-2-3-在浏览器中输入-http-localhost-8080-springBoot-say-访问"><a href="#2-2-3-在浏览器中输入-http-localhost-8080-springBoot-say-访问" class="headerlink" title="2.2.3 在浏览器中输入 http://localhost:8080/springBoot/say 访问"></a>2.2.3 在浏览器中输入 <a href="http://localhost:8080/springBoot/say">http://localhost:8080/springBoot/say</a> 访问</h3><h2 id="2-3-入门案例分析"><a href="#2-3-入门案例分析" class="headerlink" title="2.3 入门案例分析"></a>2.3 入门案例分析</h2></li><li><p><strong>SpringBoot的父级依赖spring-boot-starter-parent配置之后，当前的项目就是SpringBoot项目</strong>  </p></li><li><p><strong>sping-boot-starter-parent是一个Springboot的父级依赖，开发SpringBoot程序都需要继承该父级项目，它用来提供相关的Maven默认依赖，使用它之后，常用的jar包依赖可以省去version配置</strong>  </p></li><li><p><strong>SpringBoot提供了哪些默认jar包的依赖，可查看该父级依赖的pom文件</strong>  </p></li><li><p><strong>如果不想使用某个默认的依赖版本，可以通过pom.xml文件的属性配置覆盖各个依赖项，比如覆盖Spring版本</strong>  </p></li></ul><pre><code>&lt;properties&gt;    &lt;spring-framework.version&gt;5.0.0.RELEASE&lt;/spring-framework.version&gt;&lt;/properties&gt;</code></pre><ul><li><strong>@SpringBootApplication 注解是 SpringBoot项目的核心注解，主要作用是开启Sprin自动配置，如果在Application类上去掉该注解，那么不会开启SpringBoot程序</strong>  </li><li><strong>main方法是一个标准的java程序的main方法，主要作用是作为项目启动运行的入口</strong>  </li><li><strong>@Controller及@ResponseBody依然是我们之前的SprinMVC,因为SpringBoot的里面依然是使用我们的SpringMVC+Spring+Mybatis等框架</strong>  <h2 id="2-4-SpringBoot核心配置文件"><a href="#2-4-SpringBoot核心配置文件" class="headerlink" title="2.4 SpringBoot核心配置文件"></a>2.4 SpringBoot核心配置文件</h2></li><li><strong>SpringBoot的核心配置文件用于配置SpringBoot程序，名字必须以application开始</strong>  </li><li><strong>SpringBoot核心配置文件：resources/application.properties</strong>  <h3 id="2-4-1-核心配置格式"><a href="#2-4-1-核心配置格式" class="headerlink" title="2.4.1 核心配置格式"></a>2.4.1 核心配置格式</h3></li></ul><ol><li><strong>.properties文件（默认采用该文件）</strong><br>通过修改application.properties配置文件，在修改默认tomcat端口号以及项目上下文根，键值对的 properties 属性文件配置方式  <blockquote><p>#设置内嵌端口号<br>server.port=8888</p></blockquote></li></ol><blockquote><p>#设置上下文根<br>server.server.context-path=/springboot  </p></blockquote><ul><li><strong>配置完毕之后，启动浏览器测试</strong>  <blockquote><p>Tomcat started on port(s): 8888 (http) with context path ‘/springboot’  </p></blockquote></li><li><strong>浏览器访问地址</strong>  <blockquote><p><a href="http://localhost:8888/springboot/hello/word">http://localhost:8888/springboot/hello/word</a><br><a href="http://localhost:8888/springboot/sav">http://localhost:8888/springboot/sav</a>  </p></blockquote></li></ul><ol start="2"><li><strong>yml 文件</strong><br>yml 是一种 yaml格式的配置文件，主要采用一定的空格、换行等格式排版进行配置。<br>yaml 是一种直观的能够被计算机识别的数据序列化格式，容易被人类阅读，yaml类似与xml，但是语法比xml简洁很多，值与前面的冒号配置项必须要有一个空格，yml后缀也可以使用yaml后缀  <blockquote><p>server:<br>port: 9090<br>servlet:<br> context-path: /hello  </p></blockquote></li></ol><ul><li><p><strong>浏览器访问地址</strong>  </p><blockquote><p><a href="http://localhost:9090/hello/say?data=world">http://localhost:9090/hello/say?data=world</a>  </p></blockquote></li><li><p><strong>注意：当三种格式配置文件（properties,yml,yaml）同时存在，使用的是properties配置文件，SpringBoot启动中只读取一种配置文件</strong>  </p><h3 id="2-4-2-多环境配置"><a href="#2-4-2-多环境配置" class="headerlink" title="2.4.2 多环境配置"></a>2.4.2 多环境配置</h3></li><li><p><strong>多环境下核心配置文件的使用，工作中开发的环境有哪些：开发环境，测试环境，准生产环境，生产环境</strong><br>   在实际开发过程中,我们的项目会经历很多阶段（开发-&gt;测试-&gt;上线），每个阶段的配置也会不同，例如：端口、上下文根、数据库等，那么这个时候为了方便在不同的环境之间切换、SpringBoot提供了多环境配置，具体步骤如下  </p></li><li><p>为每个环境创建一个配置文件，命名必须以<strong>application-环境标识.properties|yml</strong>   </p><p>  application-dev.properties  </p></li></ul><blockquote><p>#开发环境配置文件<br>server.port=8081<br>server.servlet.context-path=/dev  </p></blockquote><pre><code>application-product.properties  </code></pre><blockquote><p>#生产环境配置文件<br>server.port=8082<br>server.servlet.context-path=/product  </p></blockquote><pre><code>application-test.properties  </code></pre><blockquote><p>#测试环境配置文件<br>server.port=8083<br>server.servlet.context.path=/test  </p></blockquote><pre><code>application-ready.properties  </code></pre><blockquote><p>#准生产环境配置文件<br>server.port=8084<br>server.servlet.context.path=/ready  </p></blockquote><pre><code>在总配置文件 application.properties 进行环境的激活  </code></pre><blockquote><p>##SpringBoot主配置文件<br>#激活配置环境<br>#激活开发环境<br>#spring.profiles.active=dev<br>#激活生产环境<br>#spring.profiles.active=produce<br>#激活测试环境<br>spring.profiles.active=test<br>#激活准生产环境<br>#spring.profiles.active=ready  </p></blockquote><ul><li><strong>注：等号右边的值和配置文件的环境标识名一致，可以更改总配置文件的配置，yml|yaml文件步骤差不多，就不举例了</strong>  </li></ul><h3 id="2-4-3-SpringBoot-自定义配置"><a href="#2-4-3-SpringBoot-自定义配置" class="headerlink" title="2.4.3 SpringBoot 自定义配置"></a>2.4.3 SpringBoot 自定义配置</h3><pre><code>在SpringBoot的核心配置文件中，除了使用内置的配置项之外，我们还可以使用自定义配置，然后采用如下注解去读取配置的属性值  </code></pre><ol><li><strong>@Value注解</strong>   <blockquote><p>用于逐个读取application.properties中的配置  </p></blockquote></li></ol><ul><li>在核心配置文件 applicatin.properties 中，添加两个自定义配置项schoole.name和<br>website。  <blockquote><p>#设置内嵌tomcat端口号<br>server.port=8010<br>#设置上下文根<br>server.servlet.context-path=/<br>school.name = jxgm<br>websit=<a href="http://www.jxgm.springboot/">http://www.jxgm.springboot</a>  </p></blockquote></li><li>在 IndexController 中定义属性，并使用@Value 注解或者自定义配置值,对其方法进行测试  </li></ul><pre><code>@Controllerpublic class IndexController {    @Value("${school.name}")    String school;    @Value("${websit}")    String localhost;    @RequestMapping(value = "/say")    public @ResponseBody String login(){        return "Hello" + school + localhost;    }}</code></pre><ul><li><strong>运行 <a href="http://localhost:8010/sav%EF%BC%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">http://localhost:8010/sav，在浏览器中进行测试</a></strong>  </li></ul><ol start="2"><li><strong>@ConfigurationProperties</strong>  </li></ol><ul><li><p><strong>将整个文件映射成一个对象，用于自定义配置项比较多的情况</strong>    </p></li><li><p>com.jxgm.springboot.config 包下创建 School类</p><pre><code>@Component //将此类交给spring容器进行管理//将application.properties/yml配置文件中的自定义配置 相对应的前缀名的配置 映射成一个对象@ConfigurationProperties(prefix = "school")//prefix 作用可以区分同名配置public class School { String name; String websit;  public String getName() {      return name;  }  public void setName(String name) {      this.name = name;  }  public String getWebsit() {      return websit;  }  public void setWebsit(String websit) {      this.websit = websit;  }}</code></pre></li><li><p>application.properties配置文件  </p><blockquote><p>server.port=8090<br>  server.servlet.context-path=/config<br>  school.name = jxgm<br>  school.websit = <a href="http://www.jxgm.com/">http://www.jxgm.com</a><br>  abc.name = jxfz<br>  abc.websit = <a href="http://www.jxfz.com/">http://www.jxfz.com</a>  </p></blockquote></li></ul><ol start="3"><li>友情提示  </li></ol><ul><li><strong>如果是从其他地方拷贝的配置文件，一定要将里面的空格删干净</strong>   </li></ul><h2 id="2-5-SpringBoot前端使用jsp"><a href="#2-5-SpringBoot前端使用jsp" class="headerlink" title="2.5 SpringBoot前端使用jsp"></a>2.5 SpringBoot前端使用jsp</h2><h3 id="2-5-4-在pom-xml文件中配置以下依赖项"><a href="#2-5-4-在pom-xml文件中配置以下依赖项" class="headerlink" title="2.5.4 在pom.xml文件中配置以下依赖项"></a>2.5.4 在pom.xml文件中配置以下依赖项</h3><pre><code> &lt;!--引入SpringBoot内嵌Tomcat对jsp的解析依赖，不添加的话解析不了jsp--&gt;        &lt;!--仅仅只是展示jsp页面，只添加以下一个依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--如果要使用servlet必须加该以下两个依赖--&gt;        &lt;!--servlet依赖的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--如果使用 JSTL 必须添加该依赖--&gt;        &lt;!--jstl标签依赖的jar包start--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><h3 id="2-5-5-在pom。xml的build标签中要配置以下信息"><a href="#2-5-5-在pom。xml的build标签中要配置以下信息" class="headerlink" title="2.5.5 在pom。xml的build标签中要配置以下信息"></a>2.5.5 在pom。xml的build标签中要配置以下信息</h3><p>SpringBoot要求jsp文件必须编译到指定的META-INF/resources目录下才能访问，否则访问不到。其实官方已经更建议使用模板技术（后面讲解）  </p><pre><code>  &lt;!--            SpringBoot项目默认推荐使用的前端引擎是thymeleaf            现在我们要使用springBoot集成jsp，手动指定jsp最后编译的路径            而且SpringBoot集成jsp编译jsp的路径是SpringBoot规定好的位置            META-INF/resources        --&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;!--源文件--&gt;                &lt;directory&gt;src/main/webapp&lt;/directory&gt;                &lt;!--指定编译到META-INF/resources 该目标不能随便写--&gt;                &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;                &lt;!--指定源文件夹中的哪个资源要编译进行--&gt;                &lt;includes&gt;                    &lt;include&gt;*.*&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;</code></pre><h3 id="2-5-6-在application-properties文件配置-Spring-MVC的视图展示为jsp-相当于Spring-MVC-的视图解析器"><a href="#2-5-6-在application-properties文件配置-Spring-MVC的视图展示为jsp-相当于Spring-MVC-的视图解析器" class="headerlink" title="2.5.6 在application.properties文件配置 Spring MVC的视图展示为jsp,相当于Spring MVC 的视图解析器"></a>2.5.6 在application.properties文件配置 Spring MVC的视图展示为jsp,相当于Spring MVC 的视图解析器</h3><pre><code>#配置视图解析器  #其中：/表示目录为src/main/webapp  spring.mvc.view.prefix=/  spring.mvc.view.suffix=.jsp  </code></pre><ul><li><strong>集成完成后，剩下的步骤和使用SpringMVC一样</strong>  </li></ul><h3 id="2-5-7-在Controller类中编写代码"><a href="#2-5-7-在Controller类中编写代码" class="headerlink" title="2.5.7 在Controller类中编写代码"></a>2.5.7 在Controller类中编写代码</h3><pre><code>@Controllerpublic class WebController {    @RequestMapping(value = "/sav")    public @ResponseBody ModelAndView sav(){        ModelAndView mv = new ModelAndView();        mv.addObject("message","Hello SpringBoot");        mv.setViewName("index");        return mv;    }    @RequestMapping(value = "/login")    public String login(Model model){        model.addAttribute("message","Hello World");        return "index";    }}  </code></pre><h3 id="2-5-8-使用jsp获取-从Controller传递过来的数据"><a href="#2-5-8-使用jsp获取-从Controller传递过来的数据" class="headerlink" title="2.5.8 使用jsp获取 从Controller传递过来的数据"></a>2.5.8 使用jsp获取 从Controller传递过来的数据</h3><pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;${message}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><h3 id="2-5-9-运行Application，通过浏览器访问测试localhost-8080-sav-login"><a href="#2-5-9-运行Application，通过浏览器访问测试localhost-8080-sav-login" class="headerlink" title="2.5.9 运行Application，通过浏览器访问测试localhost:8080/sav|login"></a>2.5.9 运行Application，通过浏览器访问测试localhost:8080/sav|login</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3-0异步支持-AsyncSupported</title>
      <link href="post/2504.html"/>
      <url>post/2504.html</url>
      
        <content type="html"><![CDATA[<p>以下内容均来自官方文档</p><h1 id="1-为什么要异步支持？"><a href="#1-为什么要异步支持？" class="headerlink" title="1.为什么要异步支持？"></a>1.为什么要异步支持？</h1><p>应用服务器中的Web容器通常使用每个客户机请求的服务器线程。在重负载条件下，容器需要大量的线程来满足所有客户机请求。可伸缩性限制包括耗尽内存或耗尽容器线程池。要创建可伸缩的web应用程序，您必须确保没有与请求关联的线程处于闲置状态，因此容器可以使用它们来处理新请求。</p><p>简单点说，就是为了节约服务器端的资源</p><h1 id="2-异步支持的应用场景"><a href="#2-异步支持的应用场景" class="headerlink" title="2.异步支持的应用场景"></a>2.异步支持的应用场景</h1><blockquote><p>①.在构建响应之前，线程需要等待资源变为可用或处理数据。比如，一个应用程序需要查询数据库或者在生成响应之前从远程web服务访问数据。<br>②.在生成响应之前，线程需要等待一个事件。比如，一个应用程序可能必须等待一个JMS信息，在生成响应之前，等待来自另一个客户机的新信息或在队列中可用的新数据。</p></blockquote><ul><li>这些场景表示限制web应用程序可伸缩性的操作。异步处理指将这些阻塞操作分配给一个新线程，并将与请求关联的线程重新调整到容器  <h1 id="sevlet中的异步处理"><a href="#sevlet中的异步处理" class="headerlink" title="sevlet中的异步处理"></a>sevlet中的异步处理</h1>Java EE为servlet和过滤器提供异步处理支持。如果servlet或过滤器在处理请求时达到了潜在的阻塞操作，它可以将操作分配给异步执行上下文，并将与请求关联的线程立即返回到容器中，而不会生成响应。阻塞操作在不同线程中完成异步执行上下文，可以生成响应或将请求发送给另一个servlet。</li></ul><p>要在servlet上启用异步处理，可以在@WebServlet注解上将参数asyncsupport设置为true:  </p><blockquote><p>@WebServlet(value=”/some” , asyncSupported=true)<br>public class SomeServlet extends HttpServlet {……}</p></blockquote><p>javax.servlet.AsyncContext类提供了在服务方法中执行异步处理所需的功能。要获得一个AsyncContext实例，请在服务方法的请求对象上调用startAsync()方法;例如:   </p><blockquote><p>protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {<br>……<br>// 获取异步上下文对象<br>AsyncContext startAsync = request.startAsync();<br>……<br>}  </p></blockquote><p>此调用将请求放入异步模式，并确保在退出服务方法后不会提交响应。在阻塞操作完成或将请求发送到另一个servlet之后，你必须在异步上下文中生成响应。</p><p>容器提供了一个不同的线程，其中阻塞操作可以被处理。<br>AsyncContext类提供的方法：</p><p>　　　　void start(Runnable run)：为阻塞操作提供代码，作为实现Runnable接口的类。当调用start方法或使用其他机制将　　　　AsyncContext实例传递给类时，您可以将该类作为一个内部类提供。</p><p>　　　　ServletRequest getRequest()：返回用于初始化此异步上下文的请求。在上面的示例中，请求与服务方法相同。</p><p>你可以使用这个方法在异步上下文获取从请求参数。</p><p>　　　　ServletResponse getResponse()：返回用于初始化此异步上下文的响应。在上面的示例中，响应与服务方法相同。</p><p>你可以在异步上下文中使用此方法来将阻塞操作的结果写入响应。</p><p>　　　　void complete()：完成异步操作并关闭与此异步上下文关联的响应。在异步上下文中写入响应对象之后，调用此方法。</p><p>　　　　void dispatch(String path)：将请求和响应对象分派到给定的路径。在阻塞操作完成之后，使用此方法让另一个servlet写入响应。  </p><h1 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h1><p><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/1.png"><br><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/2.png"><br><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/3.png">  </p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/4.png"><br><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/5.png"><br><img src="Servlet3-0%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-AsyncSupported/6.png">  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址详解</title>
      <link href="post/227.html"/>
      <url>post/227.html</url>
      
        <content type="html"><![CDATA[<h1 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h1><h2 id="1、网络设备"><a href="#1、网络设备" class="headerlink" title="1、网络设备"></a>1、网络设备</h2><ul><li>交换机：用来组建内网的局域网的设备  <h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2></li><li><strong>局域网通讯规则</strong>：所有人必须都在<strong>同一网段内</strong>才能通讯  </li><li>IP地址构成：网络位+主机位  </li><li><strong>子网掩码</strong>：用来确定网络位，与 255 对应的是网路位，与 0 对应的是主机位  <blockquote><p>例如：192.168.0.X，前 3 位是网络位，最后一个是主机位<br>属于 192.168.0.0 网段，名字是 .X<br>子网掩码就是 255.255.255.0  </p></blockquote></li><li>ABCD 类 IP 地址： <ul><li>A 类：1-126 默认子网掩码：255.0.0.0  </li><li>B 类：128-191 默认子网掩码：255.255.0.0  </li><li>C 类：192-223 默认子网掩码：255.255.255.0  </li><li>D 类：224-239 组播地址  </li><li>E 类：244-254 科研使用</li></ul></li><li>几种特殊的 IP 地址：<ul><li>本机 IP ：127.0.0.1  </li><li>广播地址：主机位全为 255  <blockquote><p>主机位不能全为0和255  </p></blockquote></li><li>网段：主机位全为0</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于VMware的一些资源-ISO-序列号（二）</title>
      <link href="post/502f.html"/>
      <url>post/502f.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于VMware的一些资源-IOS-序列号（二）"><a href="#关于VMware的一些资源-IOS-序列号（二）" class="headerlink" title="关于VMware的一些资源|IOS|序列号（二）"></a>关于VMware的一些资源|IOS|序列号（二）</h1><h2 id="系统镜像ISO下载"><a href="#系统镜像ISO下载" class="headerlink" title="系统镜像ISO下载"></a>系统镜像ISO下载</h2><ul><li>我测试过的有 win7 和 2008 r2 server，都能在 VMware 上运行</li><li>win7 x64 专业版 -sp2：<a href="https://pan.baidu.com/s/1VskI_5J2cETrHYjkDDeh3Q">https://pan.baidu.com/s/1VskI_5J2cETrHYjkDDeh3Q</a>  提取码：1kx1  </li><li>2008r2 server企业版 -sp2：<a href="https://pan.baidu.com/s/1jWir6pvAT2DgdEDywr85cg">https://pan.baidu.com/s/1jWir6pvAT2DgdEDywr85cg</a> 提取码：m31g </li></ul><hr><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><ul><li>win7 x64 专业版：  </li><li>网盘不提供分享 私聊  </li><li>2008r2 server企业版：  </li><li>网盘不提供分享 私聊</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iso </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于VMware的一些资源|ISO|序列号</title>
      <link href="post/748b.html"/>
      <url>post/748b.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于VMware的一些资源-ISO-序列号"><a href="#关于VMware的一些资源-ISO-序列号" class="headerlink" title="关于VMware的一些资源|ISO|序列号"></a>关于VMware的一些资源|ISO|序列号</h1><h2 id="VMware下载"><a href="#VMware下载" class="headerlink" title="VMware下载"></a>VMware下载</h2><ul><li>1.5.1版本的，没什么问题，解压即用，免激活  </li><li>链接：<a href="https://pan.baidu.com/s/1MBdRm8XYViEGb8N-uGc2MA">https://pan.baidu.com/s/1MBdRm8XYViEGb8N-uGc2MA</a>  </li><li>提取码: 56s5 解压密码：-0daydown  </li></ul><hr><h2 id="系统镜像ISO下载"><a href="#系统镜像ISO下载" class="headerlink" title="系统镜像ISO下载"></a>系统镜像ISO下载</h2><ul><li>我测试过的有 xp 和 2003server，都能在 VMware 上运行  </li><li>Winxp专业版 -sp2：<a href="https://pan.baidu.com/s/16cZgPOMjczWuMp6AVyDd3g">https://pan.baidu.com/s/16cZgPOMjczWuMp6AVyDd3g</a> 提取码: d54x  </li><li>2003server企业版 -sp2：<a href="https://pan.baidu.com/s/1KQ27hMuxS3exr5eaoHBVWA">https://pan.baidu.com/s/1KQ27hMuxS3exr5eaoHBVWA</a> 提取码: kwey  </li></ul><hr><h2 id="激活序列号"><a href="#激活序列号" class="headerlink" title="激活序列号"></a>激活序列号</h2><ul><li>xp 和 2003server 都是可用的，其他版本暂时没找  </li><li>windows xp Professional：</li><li>2DJQK-6GB67-DPT8B-BJ6MQ-CT993  </li><li>win2003 Enterprise Edition sp2 企业版：  </li><li>HXCRB-TQW9R-42JK8-TQ7X2-PJRDY</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> VMware|iso| </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建个人网站or博客</title>
      <link href="post/4c56.html"/>
      <url>post/4c56.html</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="1-nodejs-Git环境搭建："><a href="#1-nodejs-Git环境搭建：" class="headerlink" title="1. nodejs,Git环境搭建："></a>1. nodejs,Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/GANWEI793089452/article/details/105295840?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160153255519724839237046%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160153255519724839237046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-105295840.pc_first_rank_v2_rank_v28&amp;utm_term=nodejs%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85&amp;spm=1018.2118.3001.4187">nodejs搭建教程：</a><br><a href="https://blog.csdn.net/qq_36880602/article/details/105326431?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160161568619724835812607%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160161568619724835812607&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-105326431.pc_first_rank_v2_rank_v28&amp;utm_term=windows%E7%B3%BB%E7%BB%9FGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2118.3001.4187">git搭建教程</a>  </li><li>注意了，Git在官网下载会非常慢，建议在各种软件园快速下载。  </li><li><a href="https://blog.csdn.net/weixin_44198965/article/details/99686507">git官网下载太慢解决方法</a> <h2 id="2-注册GitHub账号并创建仓库"><a href="#2-注册GitHub账号并创建仓库" class="headerlink" title="2. 注册GitHub账号并创建仓库"></a>2. 注册GitHub账号并创建仓库</h2></li></ul><p>1.<a href="https://blog.csdn.net/ocean_1996/article/details/103050776?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160161601519195246601721%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160161601519195246601721&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-103050776.pc_first_rank_v2_rank_v28&amp;utm_term=%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8Cgithub%E8%B4%A6%E5%8F%B7&amp;spm=1018.2118.3001.4187">注册GitHup账号</a><br>2.<a href="https://blog.csdn.net/tao_627/article/details/51407391?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160161610019724836720388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160161610019724836720388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-51407391.pc_first_rank_v2_rank_v28&amp;utm_term=%E5%88%9B%E5%BB%BAgithub%E4%BB%93%E5%BA%93&amp;spm=1018.2118.3001.4187">创建仓库</a><br>3. 格式要求：仓库名.github.io  </p><ul><li>例：yq-hash.github.io  </li></ul><ol start="4"><li><p><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/yi-jian-sheng-cheng-ssh-mi-yao">参考文档（可能用到）–Github的ssh密匙添加：</a>  </p></li><li><p><a href="https://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html">参考文档2（可能用到）–Github的ssh密匙添加：</a>  </p></li><li><p><a href="https://zhidao.baidu.com/question/749077007063150212.html">一些小伙伴找不到的可以看看，github怎么进入account settings</a>  </p><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3. 快速利用hexo搭建博客："></a>3. 快速利用hexo搭建博客：</h2></li><li><p><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju">脚本教程</a>  </p></li><li><p><a href="https://blog.csdn.net/qq_44846853/article/details/104561054?biz_id=102&amp;utm_term=matery%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-104561054&amp;spm=1018.2118.3001.4187">matery主题安装及优化</a>  </p></li><li><p><a href="https://blog.csdn.net/qq_44846853/article/details/104563887">matery主题安装及优化二</a><br><a href="https://hexo.io/themes/">matery主题官网</a></p><h2 id="安装的需要的编辑软件"><a href="#安装的需要的编辑软件" class="headerlink" title="安装的需要的编辑软件"></a>安装的需要的编辑软件</h2></li></ol><ul><li>Typora<br>个人建议在国内的网站上面下载，不要去官网  </li><li>VS code<br>轻量级文档编辑器   </li></ul><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://code.visualstudio.com/">VScode下载地址</a>  </p><h1 id="博客搭建完成"><a href="#博客搭建完成" class="headerlink" title="博客搭建完成"></a>博客搭建完成</h1><p><a href="https://yq-hash.github.io/">我的博客</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="post/3eeb.html"/>
      <url>post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
